<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WALDO Staking</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #070a18;
      color: #eafff9;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .center {
      max-width: 840px;
      margin: 20px auto;
      padding: 0 12px;
    }

    .loader {
      margin: 60px auto;
      width: 32px;
      height: 32px;
      border: 3px solid #1a1a1a;
      border-top-color: #25c2a0;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .hint {
      text-align: center;
      opacity: .8;
      font-size: 14px;
    }

    a {
      color: #9adbcf;
    }
  </style>
</head>

<body>
  <div class="center">
    <div id="mount">
      <div class="loader" aria-label="loading"></div>
      <p class="hint">Loading WALDO Staking…</p>
    </div>
  </div>

  <script>
    (function () {
      const target = document.getElementById('mount');
      const ver = (window.WALDO_WIDGET_VERSION || Date.now());
      const localSrc = 'waldo-staking-widget.html?v=' + encodeURIComponent(ver);
      const rawSrc = 'https://raw.githubusercontent.com/WALDOCOIN69/waldocoin/main/WordPress/widgets/waldo-staking-widget.html?v=' + encodeURIComponent(ver);

      async function inject(html) {
        target.innerHTML = html;
        const scripts = target.querySelectorAll('script');
        let injectedOk = true;
        for (const old of scripts) {
          try {
            const s = document.createElement('script');
            s.defer = false; s.async = false;
            if (old.src) { s.src = old.src; } else { s.textContent = old.textContent; }
            for (const a of old.attributes) s.setAttribute(a.name, a.value);
            document.body.appendChild(s);
            old.remove();
          } catch (err) {
            injectedOk = false;
            console.warn('Script inject error:', err?.message || err);
          }
        }
        // Fallback: ensure widget opens and toggle works even if inner script didn't bind
        try {
          const stake = document.getElementById('waldoStake');
          if (stake) stake.classList.remove('collapsed');
          const toggle = document.getElementById('stakeToggle');
          if (toggle) {
            toggle.addEventListener('click', () => {
              const root = document.getElementById('waldoStake');
              if (root) root.classList.toggle('collapsed');
            }, { passive: true });
          }
        } catch (_) { }
        return injectedOk;
      }

      async function loadAndInject(urlPrimary, urlFallback) {
        try {
          const r = await fetch(urlPrimary, { cache: 'no-store' });
          if (!r.ok) throw new Error('HTTP ' + r.status);
          const html = await r.text();
          const ok = await inject(html);
          // If any inline script fails to eval, fallback to raw GitHub copy
          if (!ok) throw new Error('Inline script eval failed');
        } catch (e) {
          console.warn('Primary widget failed, trying fallback:', e.message);
          try {
            const r2 = await fetch(urlFallback, { cache: 'no-store' });
            if (!r2.ok) throw new Error('HTTP ' + r2.status);
            const html2 = await r2.text();
            await inject(html2);
          } catch (e2) {
            target.innerHTML = '<p class="hint">Failed to load widget (' + e2.message + ').</p>' +
              '<p class="hint">Open the raw widget file: <a href="https://raw.githubusercontent.com/WALDOCOIN69/waldocoin/main/WordPress/widgets/waldo-staking-widget.html" target="_blank" rel="noopener">waldo-staking-widget.html</a></p>';
          }
        }
      }

      // Define safe placeholders so clicks before scripts load won't error
      (function () {
        const names = ['stakeConnect', 'stakeTrustline', 'stakeDisconnect', 'stakeLoadInfo', 'ltSetMax', 'createLongTermStake', 'redeemStake'];
        function makeStub(name) {
          function stub() {
            const args = arguments;
            const tryCall = () => {
              const f = window[name];
              if (typeof f === 'function' && f !== stub && !f._waldoStub) {
                return f.apply(window, args);
              }
              setTimeout(tryCall, 300);
            };
            tryCall();
          }
          stub._waldoStub = true;
          return stub;
        }
        for (const n of names) { if (typeof window[n] !== 'function') window[n] = makeStub(n); }
      })();



      // Final safety: if widget script failed to define handlers, provide minimal fallbacks
      (function () {
        const API = window.WALDO_API || 'https://waldocoin-backend-api.onrender.com';
        function isMobile() { return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }
        function defineIfMissing(name, fn) { if (typeof window[name] !== 'function') window[name] = fn; }
        defineIfMissing('xummOpenStake', function (title, payload) {
          const M = document.getElementById('xummModalStake'); if (!M) return;
          const QR = document.getElementById('xummQrStake');
          const LD = document.getElementById('xummLoadStake');
          const HT = document.getElementById('xummHintStake');
          const MB = document.getElementById('xummMobileStake');
          const B = document.getElementById('xummMobileBtnStake');
          const T = document.getElementById('xummTitleStake'); if (T) T.textContent = title || 'Xaman';
          const deep = (payload && (payload.qr_uri || payload.deeplink || (payload.uuid ? ('https://xumm.app/sign/' + payload.uuid) : (payload.next && (payload.next.always || payload.next.app))))) || '';
          const png = (payload && ((payload.refs && (payload.refs.qr_png || payload.refs.qr)) || payload.qr_png || payload.qr)) || '';
          M.style.display = 'block';
          if (isMobile()) {
            MB.style.display = 'flex'; if (QR) QR.style.display = 'none'; if (LD) LD.style.display = 'none'; if (HT) HT.style.display = 'none';
            if (B) B.onclick = function () { if (deep) { try { window.location.href = deep; } catch (_) { } setTimeout(function () { try { window.open(deep, '_self'); } catch (_) { } }, 150); } };
          } else {
            MB.style.display = 'none'; if (QR) QR.style.display = 'block'; if (LD) LD.style.display = 'none'; if (HT) HT.style.display = 'block';
            const link = document.getElementById('xummDesktopLinkStake'); if (link) { if (deep) { link.href = deep; link.style.display = 'inline-block'; } else { link.style.display = 'none'; } }
            if (QR) {
              if (png) { QR.onerror = function () { if (deep) QR.src = 'https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=' + encodeURIComponent(deep); }; QR.src = png; }
              else if (deep) { QR.src = 'https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=' + encodeURIComponent(deep); }
              else { QR.src = ''; }
            }
          }
        });
        defineIfMissing('xummCloseStake', function () { const m = document.getElementById('xummModalStake'); if (m) m.style.display = 'none'; });
        defineIfMissing('stakeConnect', async function () {
          try {
            const r = await fetch(API + '/api/login'); const j = await r.json();
            window.xummOpenStake('Connect Xaman', j);
            let tries = 0; const iv = setInterval(async function () {
              tries++;
              try {
                const s = await fetch(API + '/api/login/status/' + encodeURIComponent(j.uuid) + '?_t=' + Date.now());
                const st = await s.json();
                if (st && st.signed) {
                  clearInterval(iv);
                  window.__WALDO_WALLET = st.account || window.__WALDO_WALLET || '';
                  const status = document.getElementById('stakeConnStatus'); if (status) status.textContent = window.__WALDO_WALLET ? ('Wallet: ' + window.__WALDO_WALLET.slice(0, 6) + '…' + window.__WALDO_WALLET.slice(-4)) : 'Connected';
                  const btn = document.getElementById('btnStakeDisconnect'); if (btn) btn.style.display = 'inline-block';
                  window.xummCloseStake();
                }
                if (tries > 180) clearInterval(iv);
              } catch (_) { clearInterval(iv); }
            }, 1000);
          } catch (e) { alert('Connect error: ' + e.message); }
        });
        defineIfMissing('stakeTrustline', async function () {
          try {
            const r = await fetch(API + '/api/xrpl/trustline/create', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
            const j = await r.json(); if (!j.success) throw new Error(j.error || 'Trustline failed');
            window.xummOpenStake('Add WALDO Trustline', j);
          } catch (e) { alert('Trustline error: ' + e.message); }
        });
        defineIfMissing('createLongTermStake', async function () {
          const amt = parseFloat((document.getElementById('ltAmount') || {}).value || '0');
          const dur = parseInt((document.getElementById('ltDuration') || {}).value || '0');
          const msg = document.getElementById('ltMsg');
          const W = window.__WALDO_WALLET || (document.getElementById('stakeWallet') || {}).value || '';
          if (!W || !W.startsWith('r')) { if (msg) msg.textContent = 'Load your wallet info first'; return; }
          if (!amt || !dur) { if (msg) msg.textContent = 'Enter amount and select duration'; return; }
          try {
            const r = await fetch(API + '/api/staking/long-term', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ wallet: W, amount: amt, duration: dur }) });
            const j = await r.json(); if (!j.success) throw new Error(j.error || 'Lock failed');
            if (msg) msg.textContent = 'Sign in Xaman to lock ' + amt + ' WALDO for ' + dur + ' days...';
            window.xummOpenStake('Long-term Lock', j);
          } catch (e) { if (msg) msg.textContent = 'Error: ' + e.message; }
        });
      })();

      loadAndInject(localSrc, rawSrc);
    })();
  </script>
</body>

</html>