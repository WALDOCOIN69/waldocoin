<!DOCTYPE html>
<!-- WALDO Staking Widget -->
<div class="waldo-stake" id="waldoStake">
  <div class="stake-head">
    <div class="title"><span class="accent">üü¢</span> WALDO Lock & Boost</div>
    <div class="sub">30-Day Lock + ‚Ä¢ Bonus: +12% to +45% ‚Ä¢ Early unlock reduces WALDO by 15%</div>
    <div class="tabs">
      <button class="tab active" data-tab="long">Long-Term</button>
    </div>
  </div>

  <div class="stake-body">
    <!-- Controls -->
    <div class="row">
      <button class="btn cta connect" onclick="stakeConnect()">üîó Connect Xaman</button>
      <button class="btn cta trust" onclick="stakeTrustline()">‚ûï Add Trustline</button>
      <button class="btn" id="btnStakeDisconnect" onclick="stakeDisconnect()" style="display:none;">Disconnect</button>
    </div>

    <div class="row status-row">
      <div id="stakeConnStatus" class="conn">Not connected</div>
      <div id="stakeTlStatus" class="conn">Trustline: ‚Äî</div>
    </div>

    <!-- Wallet input (fallback if not connected) -->
    <div class="row wallet-row">
      <div class="col">
        <label for="stakeWallet">Wallet (XRPL r‚Ä¶)</label>
        <input id="stakeWallet" type="text" placeholder="rXXXXXXXXXXXXXXXXXXXXXXXXXXXX" />
      </div>
    </div>

    <!-- Long-term panel -->
    <div class="panel" id="panelLong">
      <div class="card">
        <div class="grid">
          <div class="field">
            <label for="ltAmount">Amount (WALDO)</label>
            <input id="ltAmount" type="number" min="1000" step="1" placeholder="Minimum 1,000" />
            <div class="subline balance-line">Balance: <span id="ltBal">‚Äî</span> WLO <button class="btn mini"
                type="button" onclick="ltSetMax()">Max</button></div>
          </div>
          <div class="field">
            <label for="ltDuration">Duration</label>
            <select id="ltDuration">
              <option value="">Select duration</option>
              <option value="30">30 days ‚Äî +12% bonus</option>
              <option value="90">90 days ‚Äî +18% bonus</option>
              <option value="180">180 days ‚Äî +25% bonus</option>
              <option value="365">365 days ‚Äî +45% bonus</option>
            </select>
          </div>
        </div>
        <div class="actions"><button class="btn buy" onclick="createLongTermStake()">Lock</button></div>
        <div id="ltMsg" class="msg"></div>
      </div>

      <div class="list">
        <h4>Your Active Long-Term Locks</h4>
        <div id="ltList"></div>
      </div>
    </div>

    <div class="list" id="ltReadyBlock" style="display:none">
      <h4>Ready to Redeem</h4>
      <div id="ltReadyList"></div>
    </div>

    <div class="list" id="ltRedeemedBlock" style="display:none">
      <h4>‚úÖ Recently Redeemed (Last 15 Days)</h4>
      <div id="ltRedeemedList"></div>
    </div>

    <div class="list" id="ltEarlyClaimedBlock" style="display:none">
      <h4>‚ö†Ô∏è Early Claimed (Last 15 Days)</h4>
      <div id="ltEarlyClaimedList"></div>
    </div>

  </div>

  <!-- XUMM Modal (minimal) -->
  <div id="xummModalStake" class="xumm-modal" style="display:none;">
    <div class="backdrop" onclick="xummCloseStake()"></div>
    <div class="content">
      <button class="close" onclick="xummCloseStake()">‚úï</button>
      <h4 id="xummTitleStake">Xaman</h4>
      <div id="xummDesktopStake" style="display:flex; flex-direction:column; align-items:center; text-align:center;">
        <img id="xummQrStake" alt="Scan with Xaman"
          style="display:none; max-width:280px; border-radius:10px; box-shadow: 0 0 18px #25c2a055;" />
        <div id="xummLoadStake" class="spin" style="display:none;"></div>
        <p id="xummHintStake" class="hint" style="display:none;">Scan the QR with your Xaman app</p>
        <div id="xummWarningStake" class="warning"
          style="display:none; margin-top:15px; padding:10px; background:rgba(255,0,0,0.1); border:1px solid #ff4444; border-radius:8px; color:#ff6666; font-size:14px; font-weight:bold; text-align:center;">
          ‚ö†Ô∏è 15% PENALTY APPLIES FOR EARLY UNLOCK
        </div>
        <a id="xummDesktopLinkStake" href="#"
          style="display:none; margin-top:10px; color:#9adbcf; text-decoration:underline;" rel="noopener"
          target="_blank">Open in Xaman (link)</a>
      </div>
      <div id="xummMobileStake" style="display:none; flex-direction:column; gap:8px; align-items:center;">
        <button id="xummMobileBtnStake" class="btn" type="button"
          style="background:#25c2a0;color:white;border:none;padding:15px 20px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;width:100%;">üì±
          Open Xaman App</button>
        <small class="hint" style="color:#9adbcf; opacity:.9;">If the app doesn‚Äôt open, copy the link and paste into
          Xaman.</small>
      </div>
    </div>
    <div id="waldoToastStake" class="toast" style="display:none;">Done</div>
  </div>
</div>

<style>
  .waldo-stake {
    --mint: #25c2a0;
    --line: #1a1a1a;
    --neonAqua: #00f7ff;
    --neonMagenta: #ff3df7;
    background: radial-gradient(600px 200px at 10% -10%, rgba(255, 61, 247, .10), transparent 60%),
      radial-gradient(600px 180px at 90% -10%, rgba(0, 247, 255, .10), transparent 60%),
      linear-gradient(180deg, #0a0c1a 0%, #0b0f23 100%);
    border: 1px solid #18213d;
    border-radius: 16px;
    box-shadow: 0 0 22px rgba(0, 247, 255, .08), 0 0 42px rgba(255, 61, 247, .06);
    width: 100%;
    max-width: 100%;
    margin: 14px 0;
    color: #eafff9;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    overflow: hidden;
  }

  .stake-head {
    text-align: center;
    position: relative;
    padding: 12px 16px 0
  }

  .title {
    text-transform: uppercase;
    letter-spacing: .8px;
    font-weight: 1000;
    font-size: 18px;
    background: linear-gradient(90deg, var(--neonAqua), var(--neonMagenta), var(--neonAqua));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    background-size: 300% 100%;
    animation: shimmer 5s linear infinite;
    text-shadow: 0 0 12px rgba(0, 247, 255, .35), 0 0 20px rgba(255, 61, 247, .25);
  }

  .title:after {
    content: "";
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -6px;
    width: 60%;
    height: 3px;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(0, 247, 255, .9), rgba(255, 61, 247, .9), rgba(0, 247, 255, .9));
    box-shadow: 0 0 10px rgba(0, 247, 255, .4), 0 0 16px rgba(255, 61, 247, .3);
    animation: shimmer 6s linear infinite;
  }

  @keyframes shimmer {
    0% {
      background-position: 0% 0
    }

    100% {
      background-position: -200% 0
    }
  }

  .tabs {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-top: 10px
  }

  .toggle {
    position: absolute;
    right: 8px;
    top: 8px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid #26335f;
    background: radial-gradient(circle, #00f7ff 0, #00f7ff 50%, transparent 51%);
    box-shadow: 0 0 10px rgba(0, 247, 255, .4);
    cursor: pointer
  }



  .trade-body,
  .stake-body {
    padding: 12px 16px 16px
  }

  .row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 10px
  }

  .col {
    flex: 1 1 260px;
    background: #101010;
    border: 1px solid #1a1a1a;
    border-radius: 10px;
    padding: 12px
  }

  .col.small {
    flex: 0 0 140px;
    display: flex;
    align-items: end
  }

  .conn {
    font-size: 12px;
    color: #9adbcf
  }

  .panel .card {
    border: 1px solid #202a4e;
    border-radius: 12px;
    padding: 12px;
    background: linear-gradient(180deg, #0a0f26, #0b112d);
    box-shadow: inset 0 0 0 1px rgba(0, 247, 255, .05)
  }

  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px
  }

  /* Badges for maturity */
  .badge {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 999px;
    font-size: 11px;
    letter-spacing: .2px;
    text-transform: uppercase;
    border: 1px solid rgba(0, 247, 255, .25);
  }


  .details {
    display: none;
    font-size: 12px;
    color: #9adbcf;
    padding-top: 6px;
    margin-top: 6px;
    border-top: 1px dashed #23345a
  }

  .btn.link {
    background: transparent;
    border-color: #2b395f;
    color: #9adbcf
  }

  .badge.soon {
    background: linear-gradient(90deg, #2a2a0f, #3b3b12);
    color: #ffef8a;
    box-shadow: 0 0 12px rgba(255, 239, 138, .15);
    border-color: rgba(255, 239, 138, .25)
  }

  .badge.mature {
    background: linear-gradient(90deg, #0f2a1a, #134a2d);
    color: #79ffcf;
    box-shadow: 0 0 12px rgba(121, 255, 207, .18);
    border-color: rgba(121, 255, 207, .25)
  }

  .badge.redeemed {
    background: linear-gradient(90deg, #1a2a0f, #2d4a13);
    color: #8fff79;
    box-shadow: 0 0 12px rgba(143, 255, 121, .18);
    border-color: rgba(143, 255, 121, .25)
  }

  .badge.warning {
    background: linear-gradient(90deg, #2a1a0f, #4a2d13);
    color: #ffb879;
    box-shadow: 0 0 12px rgba(255, 184, 121, .18);
    border-color: rgba(255, 184, 121, .25)
  }

  .badge.early-unlock {
    background: linear-gradient(90deg, #2a0f0f, #4a1313);
    color: #ff7979;
    box-shadow: 0 0 12px rgba(255, 121, 121, .18);
    border-color: rgba(255, 121, 121, .25);
    font-weight: bold;
  }

  /* Color-coded countdown based on time remaining */
  .countdown {
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 4px;
    transition: all 0.3s ease;
  }

  .countdown.danger {
    color: #ff6b6b;
    background: rgba(255, 107, 107, 0.1);
    border: 1px solid rgba(255, 107, 107, 0.2);
  }

  .countdown.warning {
    color: #ffd93d;
    background: rgba(255, 217, 61, 0.1);
    border: 1px solid rgba(255, 217, 61, 0.2);
  }

  .countdown.ready {
    color: #6bcf7f;
    background: rgba(107, 207, 127, 0.1);
    border: 1px solid rgba(107, 207, 127, 0.2);
    animation: pulse-ready 2s infinite;
  }

  @keyframes pulse-ready {

    0%,
    100% {
      box-shadow: 0 0 5px rgba(107, 207, 127, 0.3);
    }

    50% {
      box-shadow: 0 0 15px rgba(107, 207, 127, 0.6);
    }
  }

  /* Progress bar */
  .progress {
    height: 8px;
    background: #0e0e0e;
    border: 1px solid #1a1a1a;
    border-radius: 999px;
    overflow: hidden;
    margin: 8px 0 6px
  }

  .progress>span {
    display: block;
    height: 100%;
    width: 0;
    background: linear-gradient(90deg, #00f7ff, #5cffb5);
    box-shadow: 0 0 10px rgba(0, 247, 255, .35);
    transition: width .5s ease
  }

  .stake-item {
    padding: 10px 12px;
    border: 1px solid #1c254a;
    border-radius: 10px;
    background: linear-gradient(180deg, #0a0f26, #0a1020);
    margin-bottom: 10px
  }

  .stake-item .item-head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px
  }

  .stake-item .meta {
    font-size: 12px;
    color: #9adbcf;
    margin-top: 4px
  }

  .stake-item .amt {
    font-weight: 700
  }


  @media (max-width:768px) {
    .waldo-stake {
      max-width: 100%;
      margin: 14px 0;
      border-radius: 12px;
    }

    .grid {
      grid-template-columns: 1fr
    }

    .row {
      flex-direction: column;
    }

    .col {
      flex: 1 1 auto;
    }
  }

  .field input,
  .field select {
    width: 100%;
    height: 36px;
    border: 1px solid #202a4e;
    border-radius: 10px;
    padding: 8px;
    background: #0a0f26;
    color: #eafff9;
    box-shadow: inset 0 0 0 1px rgba(0, 247, 255, .05);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-size: 14px;
  }

  .actions {
    margin-top: 10px;
    display: flex;
    justify-content: center
  }

  .list {
    margin-top: 12px
  }

  .list h4 {
    color: #25c2a0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 12px;
  }

  .stake-item {
    background: linear-gradient(180deg, #0a0f26, #0a1020);
    border: 1px solid #1c254a;
    border-radius: 10px;
    padding: 12px;
    margin: 8px 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  }

  .subline {
    font-size: 12px;
    color: #9adbcf;
    margin-top: 6px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  }

  .btn {
    background: #111;
    border: 1px solid #1c1c1c;
    color: #bfeee3;
    padding: 10px 12px;
    border-radius: 10px;
    cursor: pointer;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-size: 14px;
    font-weight: 500;
  }

  .btn.buy {
    background: linear-gradient(90deg, var(--mint), #19e39a);
    color: #07120f;
    border-color: rgba(37, 194, 160, .35)
  }

  .msg {
    margin-top: 8px;
    font-size: 13px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    color: #9adbcf;
  }

  .xumm-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999
  }

  .xumm-modal .backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, .7)
  }

  .xumm-modal .content {
    position: relative;
    z-index: 1;
    background: #0d1022;
    border: 1px solid #202a4e;
    border-radius: 12px;
    padding: 16px;
    width: 92%;
    max-width: 360px;
    box-shadow: 0 0 22px rgba(0, 247, 255, .12);
    margin: auto;
    text-align: center
  }

  .xumm-modal .close {
    position: absolute;
    right: 8px;
    top: 8px;
    background: #111;
    border: 1px solid #1c1c1c;
    color: #bfeee3;
  }

  /* Enhanced prominence for Connect/Trustline buttons */

  .btn.cta {
    background: linear-gradient(90deg, #00f7ff, #ff3df7, #00f7ff);
    color: #061018;
    border: 0;
    padding: 12px 16px;
    font-weight: 900;
    box-shadow: 0 0 16px rgba(0, 247, 255, .25), 0 0 22px rgba(255, 61, 247, .16);
    transition: transform .05s ease, box-shadow .2s ease;
  }

  .btn.cta:hover {
    transform: translateY(-1px);
  }

  .btn.cta.connect {
    background: linear-gradient(90deg, #00f7ff, #19e3e3);
  }

  .btn.cta.trust {
    background: linear-gradient(90deg, #ff3df7, #ff7be9);
  }

  .btn.mini {
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 8px;
  }

  .balance-line {
    opacity: .9;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  }

  /* Fix label styling */
  .field label {
    color: #9adbcf;
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 6px;
    display: block;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  }
</style>

<!-- Inline utility functions to avoid 404 errors -->
<script>
  // Utility functions (inlined to avoid path issues)
  function calculateMaturity(endDate, bufferMs = 60 * 1000) {
    const now = Date.now();
    const end = new Date(endDate).getTime();
    const timeRemaining = Math.max(0, end - now);

    return {
      isMatured: timeRemaining <= bufferMs,
      timeRemaining,
      daysRemaining: Math.ceil(timeRemaining / (24 * 60 * 60 * 1000)),
      endTimestamp: end,
      bufferMs
    };
  }

  function formatDate(dateStr) {
    try {
      const d = new Date(dateStr);
      return d.toLocaleDateString();
    } catch (_) {
      return dateStr || '';
    }
  }

  function formatTime(dateStr) {
    try {
      const d = new Date(dateStr);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (_) {
      return '';
    }
  }
</script>

<script>
  // Track in-flight actions to prevent double-submits
  window.PENDING = window.PENDING || { redeem: new Set(), unstake: new Set() };

  // Set API endpoint for WordPress widget
  // Map to parent fallbacks when embedded via iframe and local handlers are missing
  try {
    const p = window.parent;
    const names = ['stakeConnect', 'stakeTrustline', 'createLongTermStake', 'stakeDisconnect', 'stakeLoadInfo', 'ltSetMax', 'stakeRedeem', 'stakeUnstake', 'xummOpenStake', 'xummCloseStake'];
    for (const n of names) {
      if (typeof window[n] !== 'function' && p && typeof p[n] === 'function') {
        window[n] = p[n].bind(p);
      }
    }
  } catch (_) { }


  // Prefer parent-provided API base (e.g., '/api') when embedded via iframe; fallback to hosted backend
  window.WALDO_API = window.WALDO_API || (window.parent && window.parent.WALDO_API) || 'https://waldocoin-backend-api.onrender.com';

  (function () {
    // Normalize API so code can safely call `${API}/api/...`
    const API = (function () {
      try {
        const raw = (window.WALDO_API || '').trim();
        if (!raw) return '';
        // Remove trailing slash and a single '/api' suffix if present
        return raw.replace(/\/+$/, '').replace(/\/api$/, '');
      } catch (_) { return ''; }
    })();
    const ISSUER = 'rstjAWDiqKsUMhHqiJShRSkuaZ44TXZyDY';
    const CURRENCY = 'WLO';
    let WALLET = '';
    let DURATIONS = [30];
    let CURRENT_BAL = 0;



    // Tabs
    document.querySelectorAll('.waldo-stake .tab').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.waldo-stake .tab').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const tab = btn.dataset.tab;
        document.getElementById('panelLong').style.display = tab === 'long' ? 'block' : 'none';
      })
    });

    // Xumm helpers (minimal)
    function isMobile() { return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }
    function xummOpenStake(title, payload) {
      const M = document.getElementById('xummModalStake');
      const QR = document.getElementById('xummQrStake');
      const LD = document.getElementById('xummLoadStake');
      const HT = document.getElementById('xummHintStake');
      const MB = document.getElementById('xummMobileStake');
      const B = document.getElementById('xummMobileBtnStake');
      const T = document.getElementById('xummTitleStake');
      const link = document.getElementById('xummDesktopLinkStake');
      const WARNING = document.getElementById('xummWarningStake');
      if (T) T.textContent = title || 'Xaman';

      // Show warning for staking and early unlock operations (NOT for mature redemption)
      if (WARNING) {
        const titleLower = (title || '').toLowerCase();
        if (titleLower.includes('early unlock') || (titleLower.includes('lock') && !titleLower.includes('unlock')) || (titleLower.includes('stake') && !titleLower.includes('redeem'))) {
          WARNING.style.display = 'block';
        } else {
          WARNING.style.display = 'none';
        }
      }

      // Extract UUID first - this is what we really need
      const uuid = payload?.uuid;
      const qrImg = payload?.refs?.qr_png || payload?.qr_png || payload?.refs?.qr || payload?.qr || '';

      // Build canonical deep links from payload
      const deepApp = (payload?.next?.app || '').trim();
      const deepAlways = (payload?.next?.always || '').trim();

      // Canonical web deep link
      const webDeep = uuid ? `https://xumm.app/sign/${uuid}` : (payload?.refs?.qr_uri || payload?.qr_uri || '');
      // Keep a generic deep string for desktop QR fallback
      const deepStr = deepAlways || webDeep;

      M.style.display = 'block';
      if (isMobile()) {
        MB.style.display = 'flex'; QR.style.display = 'none'; LD.style.display = 'none'; HT.style.display = 'none';
        B.onclick = () => {
          if (!uuid) {
            alert('No payload UUID found. Please try again.');
            return;
          }

          // Prefer SDK-provided app link; then robust scheme variants; then universal web link
          const urls = Array.from(new Set([
            deepApp, deepAlways,
            uuid ? `xumm://xumm.app/sign/${uuid}` : '',
            uuid ? `xumm://sign/${uuid}` : '',
            uuid ? `xaman://xumm.app/sign/${uuid}` : '',
            uuid ? `xaman://sign/${uuid}` : '',
            webDeep
          ].filter(Boolean)));

          const tryOpen = (url) => {
            let opened = false;
            // Best: open in a new context to keep this page alive
            try { const w = window.open(url, '_blank'); opened = !!w; } catch (_) { opened = false; }
            if (!opened) {
              try {
                const a = document.createElement('a');
                a.href = url; a.target = '_blank'; a.rel = 'noopener';
                document.body.appendChild(a); a.click(); a.remove();
                opened = true;
              } catch (_) { opened = false; }
            }
            // iOS fallback: hidden iframe scheme (doesn't navigate away)
            try {
              const iframe = document.createElement('iframe');
              iframe.style.display = 'none';
              iframe.src = url;
              document.body.appendChild(iframe);
              setTimeout(() => { try { document.body.removeChild(iframe); } catch (_) { } }, 1200);
            } catch (_) { }
          };

          // Sequentially try schemes; if the page didn't background, try next
          let idx = 0;
          const startVisibility = document.visibilityState;
          // Try the best candidate only to keep the page/tab alive
          const best = urls[0];
          tryOpen(best);
          // If nothing happens, user can tap again (we keep the page open)
        };
      } else {
        MB.style.display = 'none'; QR.style.display = 'block'; LD.style.display = 'none'; HT.style.display = 'block';
        if (link) { if (webDeep) { link.href = webDeep; link.style.display = 'inline-block'; } else { link.style.display = 'none'; } }
        if (qrImg) {
          QR.onerror = () => { if (deepStr) QR.src = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(deepStr)}`; };
          QR.src = qrImg;
        } else if (deepStr) {
          QR.src = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(deepStr)}`;
        } else {
          QR.src = '';
        }
      }
    }
    window.xummCloseStake = () => { document.getElementById('xummModalStake').style.display = 'none'; };

    // Connect/Disconnect (display only ‚Äî wallet still editable)
    window.stakeConnect = async function () {
      try {
        const r = await fetch(`${API}/api/login`);
        const j = await r.json();
        try { if (j?.uuid) localStorage.setItem('waldo_login_uuid', j.uuid); } catch (_) { }
        xummOpenStake('Connect Xaman', j);
        startLoginStatusPoll(j.uuid, async (s) => {
          try { localStorage.removeItem('waldo_login_uuid'); } catch (_) { }
          WALLET = s?.account || WALLET;
          const status = document.getElementById('stakeConnStatus');
          if (status) status.textContent = WALLET ? `Wallet: ${WALLET.slice(0, 6)}‚Ä¶${WALLET.slice(-4)}` : 'Connected';
          const btn = document.getElementById('btnStakeDisconnect'); if (btn) btn.style.display = 'inline-block';
          try { await stakeLoadInfo(); } catch (_) { }
        });
      } catch (e) {
        // Fallback to manual
        document.getElementById('stakeConnStatus').textContent = 'Connected (manual)';
        (function () { const el = document.getElementById('btnStakeDisconnect'); if (el) el.style.display = 'inline-block'; })();
        const w = document.getElementById('stakeWallet').value.trim();
        if (w) { WALLET = w; await stakeLoadInfo(); }
      }
    }

    function startLoginStatusPoll(uuid, onDone) {
      if (!uuid) return;
      let tries = 0;
      const iv = setInterval(async () => {
        tries++;
        try {
          const s = await fetch(`${API}/api/login/status?uuid=${encodeURIComponent(uuid)}&_t=${Date.now()}`);
          const j = await s.json();
          if (j?.signed) {
            clearInterval(iv);
            try { onDone && onDone(j); } catch (_) { }
            xummCloseStake();
          }
          if (tries > 180) { clearInterval(iv); }
        } catch (_) { /* ignore transient errors to keep polling */ }



      }, 1000);
    }

    // Resume login if user returns from Xaman and the page was backgrounded/reloaded
    async function resumeLoginIfNeeded() {
      try {
        const uuid = localStorage.getItem('waldo_login_uuid');
        if (!uuid) return;
        const s = await fetch(`${API}/api/login/status?uuid=${encodeURIComponent(uuid)}&_t=${Date.now()}`);
        const j = await s.json();
        if (j?.signed) {
          try { localStorage.removeItem('waldo_login_uuid'); } catch (_) { }
          WALLET = j?.account || WALLET;
          const status = document.getElementById('stakeConnStatus');
          if (status) status.textContent = WALLET ? `Wallet: ${WALLET.slice(0, 6)}‚Ä¶${WALLET.slice(-4)}` : 'Connected';
          const btn = document.getElementById('btnStakeDisconnect'); if (btn) btn.style.display = 'inline-block';
          try { await stakeLoadInfo(); } catch (_) { }
          try { xummCloseStake(); } catch (_) { }
        }
      } catch (_) { /* ignore */ }
    }

    // When tab becomes visible again, attempt to resume
    try { document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') resumeLoginIfNeeded(); }); } catch (_) { }
    // One-time check shortly after load in case the browser killed background timers
    try { setTimeout(resumeLoginIfNeeded, 1200); } catch (_) { }


    // Resume Xaman operations (trustline, lock, redeem, early unlock) when returning from the app
    async function resumeXummOpsIfNeeded() {
      if (window._resumeOpsRunning) return;
      window._resumeOpsRunning = true;
      try {
        const msg = document.getElementById('ltMsg');

        // Long-term lock
        try {
          const lockUuid = localStorage.getItem('waldo_lock_uuid');
          if (lockUuid) {
            if (msg && !msg.textContent) msg.textContent = 'Resuming lock confirmation...';
            startStakeStatusPoll(lockUuid, async () => {
              try { localStorage.removeItem('waldo_lock_uuid'); } catch (_) { }
              if (msg) msg.textContent = 'Lock confirmed on‚Äëledger ‚úî';
              try { await stakeLoadInfo(); } catch (_) { }
              try { xummCloseStake(); } catch (_) { }
            });
          }
        } catch (_) { }

        // Early unlock
        try {
          const unstakeUuid = localStorage.getItem('waldo_unstake_uuid');
          if (unstakeUuid) {
            if (msg && !msg.textContent) msg.textContent = 'Resuming unlock...';
            startUnstakeStatusPoll(unstakeUuid, async () => {
              try { localStorage.removeItem('waldo_unstake_uuid'); } catch (_) { }
              if (msg) msg.textContent = 'Unlocked ‚úî ‚Äî WALDO sent back';
              try { xummCloseStake(); } catch (_) { }
              try { await stakeLoadInfo(); } catch (_) { }
            });
          }
        } catch (_) { }

        // Redeem
        try {
          const redeemUuid = localStorage.getItem('waldo_redeem_uuid');
          if (redeemUuid) {
            if (msg && !msg.textContent) msg.textContent = 'Resuming redemption...';
            startRedeemStatusPoll(redeemUuid, async () => {
              try { localStorage.removeItem('waldo_redeem_uuid'); } catch (_) { }
              if (msg) msg.textContent = 'Redeemed ‚úî ‚Äî WALDO sent back';
              try { xummCloseStake(); } catch (_) { }
              try { await stakeLoadInfo(); } catch (_) { }
            });
          }
        } catch (_) { }

        // Trustline (no UUID status poll; refresh account state)
        try {
          const trustUuid = localStorage.getItem('waldo_trust_uuid');
          if (trustUuid) {
            if (msg && !msg.textContent) msg.textContent = 'Checking trustline...';
            try { await stakeLoadInfo(); } catch (_) { }
            try { localStorage.removeItem('waldo_trust_uuid'); } catch (_) { }
            try { xummCloseStake(); } catch (_) { }
          }
        } catch (_) { }
      } finally {
        window._resumeOpsRunning = false;
      }
    }

    // Hook resume handler on visibility change and shortly after load
    try { document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') resumeXummOpsIfNeeded(); }); } catch (_) { }
    try { setTimeout(resumeXummOpsIfNeeded, 1500); } catch (_) { }

    window.stakeDisconnect = function () {
      WALLET = ''; CURRENT_BAL = 0;
      const w = document.getElementById('stakeWallet'); if (w) w.value = '';
      const s = document.getElementById('stakeConnStatus'); if (s) s.textContent = 'Not connected';
      const b = document.getElementById('btnStakeDisconnect'); if (b) b.style.display = 'none';
      const tl = document.getElementById('stakeTlStatus'); if (tl) tl.textContent = 'Trustline: ‚Äî';
      // Clear LT UI
      const ltBal = document.getElementById('ltBal'); if (ltBal) ltBal.textContent = '‚Äî';
      const ltList = document.getElementById('ltList'); if (ltList) ltList.innerHTML = '<div class="subline">No active long‚Äëterm locks</div>';
      const ltAmt = document.getElementById('ltAmount'); if (ltAmt) ltAmt.value = '';
      const ltDur = document.getElementById('ltDuration'); if (ltDur) ltDur.value = '';
      const ltMsg = document.getElementById('ltMsg'); if (ltMsg) ltMsg.textContent = '';

      // Clear Ready to Redeem section
      const ltReadyBlock = document.getElementById('ltReadyBlock'); if (ltReadyBlock) ltReadyBlock.style.display = 'none';
      const ltReadyList = document.getElementById('ltReadyList'); if (ltReadyList) ltReadyList.innerHTML = '';

      // Clear Recently Redeemed section
      const ltRedeemedBlock = document.getElementById('ltRedeemedBlock'); if (ltRedeemedBlock) ltRedeemedBlock.style.display = 'none';
      const ltRedeemedList = document.getElementById('ltRedeemedList'); if (ltRedeemedList) ltRedeemedList.innerHTML = '';

      // Clear Early Claimed section
      const ltEarlyClaimedBlock = document.getElementById('ltEarlyClaimedBlock'); if (ltEarlyClaimedBlock) ltEarlyClaimedBlock.style.display = 'none';
      const ltEarlyClaimedList = document.getElementById('ltEarlyClaimedList'); if (ltEarlyClaimedList) ltEarlyClaimedList.innerHTML = '';

    }

    // Trustline
    window.stakeTrustline = async function () {
      try {
        const r = await fetch(`${API}/api/xrpl/trustline/create`, { method: 'POST', headers: { 'Content-Type': 'application/json' } });
        const j = await r.json();
        if (!j.success) throw new Error(j.error || 'Trustline failed');
        try { if (j?.uuid) localStorage.setItem('waldo_trust_uuid', j.uuid); } catch (_) { }
        xummOpenStake('Add WALDO Trustline', j);
      } catch (e) { alert('Trustline error: ' + e.message); }
    }

    // Load user info + lock durations
    window.stakeLoadInfo = async function () {
      try {
        const field = document.getElementById('stakeWallet');
        const inputVal = (field?.value || '').trim();
        const w = WALLET || inputVal;
        const isValid = window.StakingUtils?.isValidWallet || ((wallet) => wallet && wallet.startsWith('r') && wallet.length >= 25);
        if (!isValid(w)) return alert('Enter a valid XRPL wallet');
        WALLET = w;
        const r = await fetch(`${API}/api/staking/info/${encodeURIComponent(WALLET)}`);
        const j = await r.json();
        if (!j.success) throw new Error(j.error || 'Failed to load user info');

        // Also get positions (including redeemed stakes)
        const positionsR = await fetch(`${API}/api/staking/positions/${encodeURIComponent(WALLET)}`);
        const positionsJ = await positionsR.json();
        const allPositions = positionsJ.success ? positionsJ.positions : [];
        // Update TL status with error handling
        try {
          const tl = await fetch(`${API}/api/xrpl/trustline/status?account=${encodeURIComponent(WALLET)}`);
          if (tl.ok) {
            const tlj = await tl.json();
            document.getElementById('stakeTlStatus').textContent = `Trustline: ${tlj.trustline ? 'Yes' : 'No'}`;
          } else {
            console.warn('[TRUSTLINE] Status check failed:', tl.status, tl.statusText);
            document.getElementById('stakeTlStatus').textContent = 'Trustline: Check failed';
          }
        } catch (trustlineError) {
          console.warn('[TRUSTLINE] Status check error:', trustlineError.message);
          document.getElementById('stakeTlStatus').textContent = 'Trustline: ‚Äî';
        }
        // Update duration options based on user level
        const sel = document.getElementById('ltDuration');
        const userLevel = j.userInfo?.level || 1;
        const availableDurations = j.userInfo?.availableDurations || [30, 90];

        Array.from(sel.options).forEach(op => {
          if (!op.value) return; // Skip "Select duration" option
          const duration = parseInt(op.value);
          const isAvailable = availableDurations.includes(duration);

          if (isAvailable) {
            op.disabled = false;
            // Reset to original text
            const bonusText = {
              30: '30 days ‚Äî +12% bonus',
              90: '90 days ‚Äî +18% bonus',
              180: '180 days ‚Äî +25% bonus',
              365: '365 days ‚Äî +45% bonus'
            };
            op.textContent = bonusText[duration] || op.textContent;
          } else {
            op.disabled = true;
            const bonusText = {
              30: '+12% bonus',
              90: '+18% bonus',
              180: '+25% bonus',
              365: '+45% bonus'
            };
            op.textContent = op.textContent.split(' ‚Äî')[0] + ` ‚Äî ${bonusText[duration]} ‚Äî Not available for your level`;
          }
        });
        // Update WALDO balance and show in UI
        CURRENT_BAL = (j.userInfo && typeof j.userInfo.currentBalance === 'number') ? j.userInfo.currentBalance : 0;
        const balStr = Math.floor(CURRENT_BAL).toLocaleString();
        (function () { const el = document.getElementById('ltBal'); if (el) el.textContent = balStr; })();

        // SIMPLE APPROACH: Check if any countdown shows READY to determine section
        const now = Date.now();
        const bufferMs = 60 * 1000; // 60-second buffer to match backend

        const activeStakes = [];
        const readyStakes = [];

        allPositions.forEach(s => {
          if (s.status !== 'active') return;

          const endMs = +new Date(s.endDate || Date.now());
          const timeRemaining = Math.max(0, endMs - now);
          const isTimeReady = timeRemaining <= bufferMs;

          // Check if this stake's countdown would show READY
          const wouldShowReady = timeRemaining <= bufferMs;

          console.log(`[SECTION-FILTER] Stake ${s.stakeId}:`, {
            endDate: s.endDate,
            timeRemaining: timeRemaining,
            wouldShowReady: wouldShowReady,
            section: wouldShowReady ? 'READY' : 'ACTIVE'
          });

          if (wouldShowReady) {
            readyStakes.push(s);
          } else {
            activeStakes.push(s);
          }
        });
        const redeemedStakes = allPositions.filter(s => s.status === 'redeemed' || s.status === 'completed');




        // Separate mature redemptions from early claims
        // SIMPLE FIX: Use status to determine type
        // 'completed' = early unlock (with penalty)
        // 'redeemed' = mature redemption (with rewards)
        const earlyClaims = redeemedStakes.filter(s => s.status === 'completed');
        const matureRedemptions = redeemedStakes.filter(s => s.status === 'redeemed');

        // Sort both lists by most recent first (newest at top)
        const sortByMostRecent = (a, b) => {
          const timeA = new Date(a.unstakedAt || a.redeemedAt || a.processedAt || 0).getTime();
          const timeB = new Date(b.unstakedAt || b.redeemedAt || b.processedAt || 0).getTime();
          return timeB - timeA; // Descending order (newest first)
        };

        earlyClaims.sort(sortByMostRecent);
        matureRedemptions.sort(sortByMostRecent);

        console.log(`[STAKING] Found ${earlyClaims.length} early unlocks, ${matureRedemptions.length} mature redemptions`);



        renderLongTerm(activeStakes);
        renderReady(readyStakes);
        renderRedeemed(matureRedemptions);
        renderEarlyClaimed(earlyClaims);

        document.getElementById('stakeConnStatus').textContent = `Wallet: ${WALLET.slice(0, 6)}‚Ä¶${WALLET.slice(-4)}`;
      } catch (e) {
        console.log('Load info failed silently (likely CORS issue):', e.message);
        // Don't show alert to user - they can manually refresh if needed
      }
    }
    // Quick actions
    window.ltSetMax = function () {
      if (typeof CURRENT_BAL === 'number') {
        const v = Math.floor(CURRENT_BAL);
        document.getElementById('ltAmount').value = v > 0 ? v : 0;
      }
    }



    // Load shared utilities if available, otherwise define locally
    const fmtDate = window.StakingUtils?.formatDate || function (s) {
      try { const d = new Date(s); return d.toLocaleDateString(); } catch (_) { return s || '' }
    };
    const fmtTime = window.StakingUtils?.formatTime || function (s) {
      try { const d = new Date(s); return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); } catch (_) { return '' }
    };
    const calcAccrued = window.StakingUtils?.calculateAccrued || function (amount, apy, startDate, endDate) {
      const now = Date.now();
      const st = +new Date(startDate || 0);
      const ed = +new Date(endDate || 0);
      if (!isFinite(st) || !isFinite(ed) || st <= 0 || ed <= 0) return 0;

      // Calculate progress-based accrual of the flat bonus
      const totalDuration = ed - st;
      const elapsed = Math.min(now - st, totalDuration);
      const progress = totalDuration > 0 ? Math.max(0, Math.min(1, elapsed / totalDuration)) : 0;

      // Full reward is flat bonus percentage
      const fullReward = amount * (parseFloat(String(apy).replace('%', '')) / 100);
      const accruedReward = fullReward * progress;

      return Math.floor(accruedReward * 100) / 100; // Match backend rounding
    };
    function ensureCountdownTick() {
      // Use shared utility if available, otherwise use local implementation
      if (window.StakingUtils?.setupCountdownTimer) {
        window.StakingUtils.setupCountdownTimer('.waldo-stake .countdown[data-end]');
      } else {
        // Local fallback implementation
        if (window._stakeCountdownTimer) return;
        window._stakeCountdownTimer = setInterval(() => {
          document.querySelectorAll('.waldo-stake .countdown[data-end]').forEach(el => {
            const end = Number(el.dataset.end || 0);
            const totalDuration = Number(el.dataset.duration || 30);
            if (!end) return;
            const diff = Math.max(0, end - Date.now());
            const daysLeft = Math.ceil(diff / (24 * 60 * 60 * 1000));

            el.classList.remove('danger', 'warning', 'ready');

            const percentRemaining = (daysLeft / totalDuration) * 100;
            const bufferMs = 60 * 1000;
            if (diff <= bufferMs) {
              el.classList.add('ready');
              el.textContent = 'READY!';

              // TRIGGER COMPLETE RE-FILTERING when countdown becomes ready
              if (!el.classList.contains('refilter-triggered')) {
                el.classList.add('refilter-triggered');
                console.log(`[COUNTDOWN] ‚úÖ Countdown became READY! Triggering complete re-filter...`);

                // Trigger complete refresh to move stake to correct section
                setTimeout(() => {
                  console.log('[COUNTDOWN] Calling stakeLoadInfo() to re-filter sections...');
                  if (typeof stakeLoadInfo === 'function') {
                    stakeLoadInfo().catch(e => console.warn('Auto re-filter failed:', e));
                  }
                }, 500);
              }
            } else if (percentRemaining <= 25) {
              el.classList.add('danger');
            } else if (percentRemaining <= 50) {
              el.classList.add('warning');
            }

            if (diff > bufferMs) {
              if (diff <= 24 * 60 * 60 * 1000) {
                const h = Math.floor(diff / 3600000);
                const m = Math.floor((diff % 3600000) / 60000);
                const s = Math.floor((diff % 60000) / 1000);
                el.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
              } else {
                el.textContent = `${daysLeft}d`;
              }
            }
          });
        }, 1000);
      }
    }



    function renderLongTerm(list) {
      const root = document.getElementById('ltList');
      root.innerHTML = (list || []).map(s => {
        const dr = Math.max(0, parseInt(s.daysRemaining || 0));
        const total = Math.max(1, parseInt(s.duration || 0));
        const done = Math.max(0, Math.min(total, total - dr));
        const pct = Math.max(0, Math.min(100, Math.round((done / total) * 100)));

        // FIXED: Use only time-based calculation for initial rendering
        const endMs = +new Date(s.endDate || Date.now());
        const now = Date.now();
        const timeRemaining = Math.max(0, endMs - now);
        const bufferMs = 60 * 1000; // 60-second buffer
        const mature = timeRemaining <= bufferMs;

        const realTimeDaysRemaining = Math.ceil(timeRemaining / (24 * 60 * 60 * 1000));
        const soon = !mature && realTimeDaysRemaining > 0 && realTimeDaysRemaining <= 7;
        const accrued = calcAccrued(Number(s.amount || 0), s.apy, s.startDate, s.endDate);
        const badge = mature ? '<span class="badge mature">Matured</span>' : (soon ? '<span class="badge soon">Maturing Soon</span>' : '');



        // Determine initial countdown color class using real-time calculation
        const percentRemaining = (realTimeDaysRemaining / total) * 100;
        let countdownClass = '';
        if (mature) {
          countdownClass = 'ready';
        } else if (percentRemaining <= 25) {
          countdownClass = 'danger';
        } else if (percentRemaining <= 50) {
          countdownClass = 'warning';
        }

        return `
        <div class="stake-item" data-stake-id="${s.stakeId}">
          <div class="item-head">
            <div class="amt">${Number(s.amount).toLocaleString()} WALDO</div>
            ${badge}
          </div>
          <div class="meta">Duration: ${s.duration} days ‚Ä¢ Bonus: +${s.apy}% ‚Ä¢ Est. Reward: ${s.expectedReward} WALDO ‚Ä¢ Days Left: <span class="countdown ${countdownClass}" data-end="${endMs}" data-duration="${s.duration}">${mature ? 'READY!' : dr + 'd'}</span></div>
          <div class="progress"><span style="width:${pct}%"></span></div>
          <div class="details">
            <div>Start: ${fmtDate(s.startDate)} ${fmtTime(s.startDate)} ‚Ä¢ End: ${fmtDate(s.endDate)} ${fmtTime(s.endDate)} ‚Ä¢ Progress: ${pct}%</div>
            <div>Accrued so far: ${accrued.toFixed(2)} WALDO</div>
          </div>
          <div class="actions" data-stake-id="${s.stakeId}">
            ${mature ? `<button class="btn buy" onclick="stakeRedeem('${s.stakeId}')">Redeem</button>` : `<button class="btn" onclick="stakeUnstake('${s.stakeId}')">Unlock</button>`}
          </div>
        </div>`
      }).join('') || '<div class="subline">No active long‚Äëterm locks</div>';
      ensureCountdownTick();
    }

    function renderReady(list) {
      const block = document.getElementById('ltReadyBlock');
      const root = document.getElementById('ltReadyList');
      const now = Date.now();
      const bufferMs = 60 * 1000; // 60-second buffer to match backend
      const ready = (list || []).filter(s => {
        const endMs = +new Date(s.endDate || Date.now());
        const timeRemaining = Math.max(0, endMs - now);
        return timeRemaining <= bufferMs; // Use real-time check with buffer
      });
      if (!ready.length) { if (block) block.style.display = 'none'; if (root) root.innerHTML = ''; return; }
      if (block) block.style.display = 'block';
      if (root) root.innerHTML = ready.map(s => `
        <div class="stake-item">
          <div class="item-head">
            <div class="amt">${Number(s.amount).toLocaleString()} WALDO</div>
            <span class="badge mature">Matured</span>
          </div>
          <div class="meta">Locked ${s.duration}d ‚Ä¢ Bonus: +${s.apy}% ‚Ä¢ Est. Reward: ${s.expectedReward} WALDO</div>
          <div class="meta">Started: ${fmtDate(s.startDate)} ${fmtTime(s.startDate)} ‚Ä¢ Matured: ${fmtDate(s.endDate)} ${fmtTime(s.endDate)}</div>
          <div class="actions">
            <button class="btn buy" data-stake-id="${s.stakeId}" ${(window.PENDING && window.PENDING.redeem && window.PENDING.redeem.has(s.stakeId)) ? 'disabled' : ''} onclick="stakeRedeem('${s.stakeId}', this)">Redeem</button>
          </div>
        </div>
      `).join('');
    }

    function renderEarlyClaimed(list) {
      const block = document.getElementById('ltEarlyClaimedBlock');
      const root = document.getElementById('ltEarlyClaimedList');
      const earlyClaimed = (list || []); // Already filtered to early claims only

      // Render early unlock stakes with red badges

      if (!earlyClaimed.length) {
        console.log('[DEBUG] No early claims to show, hiding section');
        if (block) block.style.display = 'none';
        if (root) root.innerHTML = '';
        return;
      }
      if (block) block.style.display = 'block';
      if (root) root.innerHTML = earlyClaimed.map(s => {
        // This function only handles early claims (already filtered)

        // DEBUG: Log timestamp fields for early unlocks with alert to make it visible
        console.warn(`üî¥ EARLY-TIMESTAMP ${s.stakeId}:`, {
          unstakedAt: s.unstakedAt,
          processedAt: s.processedAt,
          completedAt: s.completedAt,
          redeemedAt: s.redeemedAt
        });

        // Try multiple timestamp fields for completion date
        const completionDate = s.unstakedAt || s.processedAt || s.completedAt || s.redeemedAt;
        let dateTime = null;

        // Robust date parsing
        if (completionDate) {
          try {
            dateTime = new Date(completionDate);
            // Check if date is valid
            if (isNaN(dateTime.getTime())) {
              console.warn(`[TIMESTAMP] Invalid date for stake ${s.stakeId}:`, completionDate);
              dateTime = null;
            }
          } catch (e) {
            console.warn(`[TIMESTAMP] Date parsing error for stake ${s.stakeId}:`, e.message);
            dateTime = null;
          }
        }

        const dateStr = dateTime ? dateTime.toLocaleDateString() : 'Unknown';
        const timeStr = dateTime ? dateTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

        const originalAmount = Number(s.originalAmount || s.amount || 0);

        // Early unlock - calculate 15% penalty
        const penalty = Number(s.penalty || (originalAmount * 0.15));
        const rewardAmount = -penalty; // Show as negative penalty
        const totalReceived = originalAmount - penalty; // What user actually received
        const actionText = `Early unlock on ${dateStr} at ${timeStr}`;
        const badgeText = 'EARLY UNLOCK';

        const explorerLink = s.unstakeTx || s.redeemTx || s.txid;
        const txLink = explorerLink ? `https://livenet.xrpl.org/transactions/${explorerLink}` : null;

        // No NEW badge logic - removed for simplicity

        return `
        <div class="stake-item">
          <div class="item-head">
            <div class="amt">${originalAmount.toLocaleString()} ${rewardAmount >= 0 ? '+' : '-'} ${Math.abs(rewardAmount).toLocaleString()} = ${totalReceived.toLocaleString()} WALDO</div>
            <span class="badge early-unlock">${badgeText}</span>
          </div>
          <div class="meta">
            ${actionText} ‚Ä¢ ${s.duration}d lock ‚Ä¢ ${s.apy}% APY
            ${txLink ? ` ‚Ä¢ <a href="${txLink}" target="_blank" rel="noopener" style="color:#25c2a0;">View Transaction</a>` : ''}
          </div>
        </div>
      `;
      }).join('');
    }

    function renderRedeemed(list) {
      const block = document.getElementById('ltRedeemedBlock');
      const root = document.getElementById('ltRedeemedList');
      const redeemed = (list || []); // Already filtered to mature redemptions only
      if (!redeemed.length) { if (block) block.style.display = 'none'; if (root) root.innerHTML = ''; return; }
      if (block) block.style.display = 'block';
      if (root) root.innerHTML = redeemed.map(s => {
        // This function now only handles mature redemptions (already filtered)

        // DEBUG: Log timestamp fields for mature redemptions with alert to make it visible
        console.warn(`üü¢ MATURE-TIMESTAMP ${s.stakeId}:`, {
          redeemedAt: s.redeemedAt,
          unstakedAt: s.unstakedAt,
          processedAt: s.processedAt,
          completedAt: s.completedAt
        });

        // Try multiple timestamp fields for completion date
        const completionDate = s.redeemedAt || s.unstakedAt || s.processedAt || s.completedAt;
        let dateTime = null;

        // Robust date parsing
        if (completionDate) {
          try {
            dateTime = new Date(completionDate);
            // Check if date is valid
            if (isNaN(dateTime.getTime())) {
              console.warn(`[TIMESTAMP] Invalid date for stake ${s.stakeId}:`, completionDate);
              dateTime = null;
            }
          } catch (e) {
            console.warn(`[TIMESTAMP] Date parsing error for stake ${s.stakeId}:`, e.message);
            dateTime = null;
          }
        }

        const dateStr = dateTime ? dateTime.toLocaleDateString() : 'Unknown';
        const timeStr = dateTime ? dateTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

        const originalAmount = Number(s.originalAmount || s.amount || 0);

        // Mature redemption - show full rewards (early unlocks should be filtered out already)
        const rewardAmount = Number(s.rewardAmount || s.expectedReward || (originalAmount * (parseFloat(s.apy || 12) / 100)));
        const totalReceived = originalAmount + Math.abs(rewardAmount); // Always positive for mature redemptions
        const actionText = `Redeemed on ${dateStr} at ${timeStr}`;
        const badgeText = '‚úÖ Redeemed';
        const badgeClass = 'redeemed';

        const explorerLink = s.redeemTx || s.unstakeTx || s.txid;
        const txLink = explorerLink ? `https://livenet.xrpl.org/transactions/${explorerLink}` : null;

        // No NEW badge logic - removed for simplicity

        return `
        <div class="stake-item">
          <div class="item-head">
            <div class="amt">${originalAmount.toLocaleString()} ${rewardAmount >= 0 ? '+' : '-'} ${Math.abs(rewardAmount).toLocaleString()} = ${totalReceived.toLocaleString()} WALDO</div>
            <span class="badge ${badgeClass}">${badgeText}</span>
          </div>
          <div class="meta">
            ${actionText} ‚Ä¢ ${s.duration}d lock ‚Ä¢ ${s.apy}% APY
            ${txLink ? ` ‚Ä¢ <a href="${txLink}" target="_blank" rel="noopener" style="color:#25c2a0;">View Transaction</a>` : ''}
          </div>
        </div>`;
      }).join('');
    }

    // Create stakes
    window.createLongTermStake = async function () {
      const amt = parseFloat(document.getElementById('ltAmount').value || '0');
      const dur = parseInt(document.getElementById('ltDuration').value || '0');
      const msg = document.getElementById('ltMsg');
      if (!WALLET) return msg.textContent = 'Load your wallet info first';
      if (!amt || !dur) return msg.textContent = 'Enter amount and select duration';
      try {
        const r = await fetch(`${API}/api/staking/long-term`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ wallet: WALLET, amount: amt, duration: dur }) });
        const j = await r.json();
        if (!j.success) throw new Error(j.error || 'Lock failed');
        try { if (j?.uuid) localStorage.setItem('waldo_lock_uuid', j.uuid); } catch (_) { }
        msg.textContent = `Sign in Xaman to lock ${amt} WALDO for ${dur} days...`;
        xummOpenStake('Long‚Äëterm Lock', j);
        if (j.uuid) startStakeStatusPoll(j.uuid, async () => { try { localStorage.removeItem('waldo_lock_uuid'); } catch (_) { } msg.textContent = 'Lock confirmed on‚Äëledger ‚úî'; await stakeLoadInfo(); });
      } catch (e) { msg.textContent = 'Error: ' + e.message; }
    }



    // Unstake (with QR code) - should only be called for early unstaking
    window.stakeUnstake = async function (stakeId) {
      // Prevent double-clicking
      if (window._unstaking && window._unstaking[stakeId]) {
        console.log('[UNSTAKE] Already processing', stakeId);
        return;
      }

      // CRITICAL: Always check if this stake is actually mature before showing penalty warning
      console.log('[UNSTAKE] Checking real-time maturity for stake:', stakeId);
      try {
        const r = await fetch(`${API}/api/staking/positions/${encodeURIComponent(WALLET)}`);
        const j = await r.json();
        if (j.success) {
          const stake = j.positions.find(p => p.stakeId === stakeId);
          if (stake) {
            const now = Date.now();
            const endMs = +new Date(stake.endDate || Date.now());
            const timeRemaining = Math.max(0, endMs - now);
            const bufferMs = 60 * 1000;

            console.log('[UNSTAKE] Maturity check:', {
              stakeId,
              endDate: stake.endDate,
              timeRemaining,
              bufferMs,
              isMature: timeRemaining <= bufferMs
            });

            if (timeRemaining <= bufferMs) {
              console.log('[UNSTAKE] ‚úÖ Stake is mature! Redirecting to redeem (no penalty)');
              alert('This stake is now mature! Redirecting to penalty-free redemption...');
              return stakeRedeem(stakeId);
            } else {
              console.log('[UNSTAKE] ‚ö†Ô∏è Stake is still early, will apply 15% penalty');
            }
          }
        }
      } catch (e) {
        console.warn('[UNSTAKE] Could not check maturity, proceeding with unstake:', e);
      }

      if (!confirm('‚ö†Ô∏è EARLY UNLOCK WARNING ‚ö†Ô∏è\n\nThis stake is not yet mature. Early unlock will reduce your WALDO by 15%.\n\nAre you sure you want to proceed with the penalty?')) return;

      // Mark as processing
      window._unstaking = window._unstaking || {};
      window._unstaking[stakeId] = true;

      // OPTIMISTIC UPDATE: Find and hide the stake item immediately
      const unstakeBtn = document.querySelector(`button[onclick="stakeUnstake('${stakeId}')"]`);
      const stakeItem = unstakeBtn ? unstakeBtn.closest('.stake-item') : null;

      if (unstakeBtn) {
        unstakeBtn.disabled = true;
        unstakeBtn.textContent = 'Processing...';
      }

      // Hide the stake item immediately (optimistic update)
      if (stakeItem) {
        stakeItem.style.opacity = '0.5';
        stakeItem.style.pointerEvents = 'none';
        stakeItem.setAttribute('data-unstaking', 'true');
      }

      const msg = document.getElementById('ltMsg');
      try {
        console.log('[UNSTAKE] Starting unstake for:', stakeId);

        // Retry logic for 502/CORS issues
        let r;
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            console.log(`[UNSTAKE] Attempt ${attempt}/3`);
            r = await fetch(`${API}/api/staking/unstake`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ wallet: WALLET, stakeId })
            });
            if (r.ok || r.status !== 502) break; // Success or non-502 error
            if (attempt < 3) {
              console.log(`[UNSTAKE] Got ${r.status}, retrying in 2s...`);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          } catch (e) {
            console.log(`[UNSTAKE] Attempt ${attempt} failed:`, e.message);
            if (attempt === 3) throw e;
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
        const j = await r.json();

        if (!j.success) throw new Error(j.error || 'Unlock failed');

        // SUCCESS CASES: Keep row hidden and complete removal
        console.log('[UNSTAKE] Checking success cases - already:', !!j.already, 'inProgress:', !!j.inProgress, 'txid:', !!j.txid);
        if (j.already || j.inProgress || j.txid) {
          console.log('[UNSTAKE] SUCCESS CASE MATCHED - returning early');
          const successMsg = j.already ? 'Already unlocked ‚úî' :
            j.inProgress ? 'Unlock in progress...' :
              'Unlocked ‚úî ‚Äî WALDO sent back';
          msg.textContent = successMsg;

          // Completely remove the stake item after short delay
          setTimeout(() => {
            if (stakeItem) stakeItem.remove();
          }, 2000);

          // Background refresh to sync with server (longer delay to ensure backend processing)
          setTimeout(() => stakeLoadInfo(), 8000);

          try { xummCloseStake && xummCloseStake(); } catch (_) { }

          // Clear processing flag
          if (window._unstaking) {
            delete window._unstaking[stakeId];
          }

          console.log('[UNSTAKE] Early return completed');
          return;
        }

        console.log('[UNSTAKE] No success case matched - proceeding to QR flow');

        // Otherwise proceed with XUMM QR flow
        msg.textContent = 'Sign in Xaman to unlock your WALDO...';
        try { if (j?.uuid) localStorage.setItem('waldo_unstake_uuid', j.uuid); } catch (_) { }
        if (typeof xummOpenStake === 'function') {
          xummOpenStake('Early Unlock', j);
        }
        if (j.uuid) {
          startUnstakeStatusPoll(j.uuid, async () => {
            msg.textContent = 'Unlocked ‚úî ‚Äî WALDO sent back';
            try { xummCloseStake && xummCloseStake(); } catch (_) { }
            await stakeLoadInfo();
          });
        }
      } catch (e) {
        console.error('[UNSTAKE] Error:', e);
        msg.textContent = 'Unlock error: ' + e.message;

        // RESTORE STAKE ITEM on error (rollback optimistic update)
        if (stakeItem) {
          stakeItem.style.opacity = '1';
          stakeItem.style.pointerEvents = 'auto';
          stakeItem.removeAttribute('data-unstaking');
        }

        // Re-enable button on error
        if (unstakeBtn) {
          unstakeBtn.disabled = false;
          unstakeBtn.textContent = 'Unlock Early';
        }

        // Clear processing flag
        if (window._unstaking) {
          delete window._unstaking[stakeId];
        }
      }
    }

    // Status polling for unstake (like exchange widget)
    function startUnstakeStatusPoll(uuid, onSuccess) {
      if (!uuid) return;
      console.log('[UNSTAKE-POLL] Starting status polling for UUID:', uuid);

      let tries = 0;
      const maxTries = 180; // 3 minutes

      const pollInterval = setInterval(async () => {
        tries++;
        console.log(`[UNSTAKE-POLL] Attempt ${tries}/${maxTries} for UUID: ${uuid}`);

        try {
          const response = await fetch(`${API}/api/staking/unstake/status/${uuid}?account=${WALLET}&txid=pending&_t=${Date.now()}`);
          const status = await response.json();
          console.log(`[UNSTAKE-POLL] Status response:`, status);

          if (status?.signed && status?.paid) {
            // Transaction completed successfully
            console.log('[UNSTAKE-POLL] Unstake completed successfully!');
            clearInterval(pollInterval);
            try { localStorage.removeItem('waldo_unstake_uuid'); } catch (_) { }
            xummCloseStake();
            if (onSuccess) onSuccess(status);
            return;
          }

          if (status?.signed && !status?.paid) {
            // Signed but payment not yet processed
            const msg = document.getElementById('ltMsg');
            if (msg && !msg._processingShown) {
              msg.textContent = 'Signed. Processing unstake...';
              msg._processingShown = true;
            }
          }

        } catch (error) {
          console.error('[UNSTAKE-POLL] Polling error:', error);
          // Continue polling despite errors - backend might be temporarily unavailable
        }

        // Stop polling after max attempts
        if (tries >= maxTries) {
          console.log('[UNSTAKE-POLL] Max attempts reached, stopping poll');
          clearInterval(pollInterval);
          // Don't auto-close on timeout - user might still be signing
        }

      }, 1000); // Poll every second like exchange widget
    }



    // Redeem (maturity only, long-term visible here)
    window.stakeRedeem = async function (stakeId, btnEl) {
      try { if (btnEl) { btnEl.disabled = true; btnEl.textContent = 'Processing‚Ä¶'; } } catch (_) { }
      try { window.PENDING?.redeem?.add(stakeId); } catch (_) { }
      const msg = document.getElementById('ltMsg');
      try {
        const r = await fetch(`${API}/api/staking/redeem`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ wallet: WALLET, stakeId }) });
        const j = await r.json();
        if (!j.success) throw new Error(j.error || 'Redeem init failed');
        try { if (j?.uuid) localStorage.setItem('waldo_redeem_uuid', j.uuid); } catch (_) { }
        msg.textContent = 'Sign in Xaman to redeem your WALDO + bonus...';
        xummOpenStake('Redeem Stake', j);

        // Start status polling for redemption completion
        startRedeemStatusPoll(j.uuid, async (result) => {
          console.log('[REDEEM] Redemption completed:', result);
          msg.textContent = 'Redeemed ‚úî ‚Äî WALDO sent back';

          // Force refresh UI to show stake in "Recently Redeemed"
          setTimeout(async () => {
            try {
              await stakeLoadInfo();
              console.log('[REDEEM] UI refreshed after redemption completion');
            } catch (error) {
              console.log('[REDEEM] UI refresh failed:', error.message);
            }
          }, 1000);
        });

        // Optimistic: remove from Ready list immediately to prevent double-clicks
        try { await stakeLoadInfo(); } catch (_) { }

        // Add 15-second fallback timeout for CORS issues
        setTimeout(async () => {
          console.log('[REDEEM] 15-second timeout - closing modal and refreshing');
          try { xummCloseStake && xummCloseStake(); } catch (_) { }
          msg.textContent = 'Redeemed ‚úî ‚Äî WALDO sent back';

          // Force refresh with delay to ensure backend processing is complete
          setTimeout(async () => {
            try {
              // First try to trigger backend processing by calling status endpoint
              if (j.uuid) {
                try {
                  const statusResponse = await fetch(`${API}/api/staking/redeem/status/${j.uuid}`);
                  const statusResult = await statusResponse.json();
                  console.log('[REDEEM] Status check result:', statusResult);
                } catch (statusError) {
                  console.log('[REDEEM] Status check failed (expected with CORS):', statusError.message);
                }
              }

              // Then refresh UI
              await stakeLoadInfo();
            } catch (error) {
              console.log('[REDEEM] Refresh failed silently (CORS issue), trying again in 3 seconds:', error.message);
              setTimeout(async () => {
                try {
                  await stakeLoadInfo();
                } catch (retryError) {
                  console.log('[REDEEM] Retry refresh also failed silently:', retryError.message);
                  // Final fallback: show message to user to manually refresh
                  if (msg) msg.textContent = 'Redeemed ‚úî ‚Äî Click "Load Info" to refresh your stakes';
                }
              }, 3000);
            }
          }, 2000);
        }, 15000);

        // Skip status polling for redemption - rely on 15-second timeout to avoid CORS spam
        console.log('[REDEEM] Skipping status polling - using 15-second timeout instead to avoid CORS errors');
      } catch (e) {
        console.log('Redeem error (likely already redeemed):', e.message);
        if (msg) msg.textContent = 'This stake has already been redeemed';
        // Don't show alert popup for double redemption attempts
      }
    }






    function startRedeemStatusPoll(uuid, onDone) {
      if (!uuid) return;
      let tries = 0;
      let corsErrorCount = 0;
      const msg = document.getElementById('ltMsg');
      const iv = setInterval(async () => {
        tries++;
        try {
          const s = await fetch(`${API}/api/staking/redeem/status/${encodeURIComponent(uuid)}?_t=${Date.now()}`);

          // Reset CORS error count on successful request
          corsErrorCount = 0;

          const j = await s.json();
          if (j?.signed) {
            if (j?.error === 'missing_sender_secret') {
              clearInterval(iv);
              try { localStorage.removeItem('waldo_redeem_uuid'); } catch (_) { }
              if (msg) msg.textContent = 'Signed, but payout is not configured (admin: set WALDO_SENDER_SECRET or WALDO_DISTRIBUTOR_SECRET)';
              xummCloseStake();
              return;
            }
            if (j?.paid) {
              clearInterval(iv);
              try { localStorage.removeItem('waldo_redeem_uuid'); } catch (_) { }
              try { onDone && onDone(j); } catch (_) { }
              xummCloseStake();
              return;
            }
            // Signed but not yet paid: show interim status once
            if (msg && !msg._waitingShown) { msg.textContent = 'Signed. Delivering WALDO‚Ä¶'; msg._waitingShown = true; }
          }
          if (tries > 180) { clearInterval(iv); }
        } catch (error) {
          // Count CORS errors but don't show them to user
          if (error.message && error.message.includes('CORS')) {
            corsErrorCount++;
            console.log(`[REDEEM-POLL] CORS error ${corsErrorCount}/5 - continuing silently`);

            // If too many CORS errors, stop polling and rely on timeout
            if (corsErrorCount >= 5) {
              console.log('[REDEEM-POLL] Too many CORS errors, stopping poll - timeout will handle completion');
              clearInterval(iv);
              return;
            }
          } else {
            console.log('[REDEEM-POLL] Network error:', error.message);
          }

          // Stop after max tries
          if (tries > 180) { clearInterval(iv); }
        }
      }, 1000);
    }


    // Poll staking status
    function startStakeStatusPoll(uuid, onDone) {
      if (!uuid) return;
      let tries = 0;
      const iv = setInterval(async () => {
        tries++;
        try {
          const s = await fetch(`${API}/api/staking/status/${encodeURIComponent(uuid)}`);
          const j = await s.json();
          if (j?.signed && j?.activated) { clearInterval(iv); try { localStorage.removeItem('waldo_lock_uuid'); } catch (_) { } try { onDone && onDone(j); } catch (_) { } xummCloseStake(); }
          if (tries > 180) { clearInterval(iv); }
        } catch (_) { /* ignore */ }
      }, 2000);
    }



    // Force refresh function (can be called from console)
    window.refreshStakes = function () {
      console.log('Forcing stake refresh...');
      if (typeof stakeLoadInfo === 'function') {
        stakeLoadInfo().catch(e => console.warn('Refresh failed:', e));
      }
    };



    // Force update all stake buttons based on current maturity (can be called from console)
    window.updateAllStakeButtons = async function () {
      console.log('[UPDATE-BUTTONS] Checking all stakes for maturity updates...');

      try {
        const response = await fetch(`${API}/api/staking/positions/${encodeURIComponent(WALLET)}`);
        const data = await response.json();

        if (!data.success) {
          console.warn('[UPDATE-BUTTONS] Failed to fetch stake data');
          return;
        }

        const now = Date.now();
        const bufferMs = 60 * 1000;

        data.positions.forEach(stake => {
          if (stake.status === 'active') {
            const endMs = +new Date(stake.endDate || Date.now());
            const timeRemaining = Math.max(0, endMs - now);
            const isMature = timeRemaining <= bufferMs;

            const stakeItem = document.querySelector(`[data-stake-id="${stake.stakeId}"]`);
            if (stakeItem) {
              const actionsDiv = stakeItem.querySelector('.actions');
              const badge = stakeItem.querySelector('.badge');

              if (isMature) {
                // Update to mature state
                if (actionsDiv) {
                  actionsDiv.innerHTML = `<button class="btn buy" onclick="stakeRedeem('${stake.stakeId}')">Redeem</button>`;
                }
                if (badge && badge.classList.contains('soon')) {
                  badge.className = 'badge mature';
                  badge.textContent = 'Matured';
                }
                console.log(`[UPDATE-BUTTONS] ‚úÖ Updated ${stake.stakeId} to mature state`);
              } else {
                // Update to active state
                if (actionsDiv) {
                  actionsDiv.innerHTML = `<button class="btn" onclick="stakeUnstake('${stake.stakeId}')">Unlock</button>`;
                }
                console.log(`[UPDATE-BUTTONS] ‚è≥ Confirmed ${stake.stakeId} still active`);
              }
            }
          }
        });

        console.log('[UPDATE-BUTTONS] ‚úÖ All stake buttons updated');

      } catch (error) {
        console.error('[UPDATE-BUTTONS] Error:', error);
      }
    };

    // Update a specific stake in real-time when it becomes mature
    window.updateStakeInRealTime = async function (stakeId) {
      console.log(`[REAL-TIME] Updating stake ${stakeId} in real-time...`);

      try {
        // Get current stake data
        const response = await fetch(`${API}/api/staking/positions/${encodeURIComponent(WALLET)}`);
        const data = await response.json();

        if (!data.success) {
          console.warn('[REAL-TIME] Failed to fetch stake data:', data.error);
          return;
        }

        const stake = data.positions.find(p => p.stakeId === stakeId);
        if (!stake) {
          console.warn('[REAL-TIME] Stake not found:', stakeId);
          return;
        }

        // Check if stake is now mature
        const now = Date.now();
        const endMs = +new Date(stake.endDate || Date.now());
        const timeRemaining = Math.max(0, endMs - now);
        const bufferMs = 60 * 1000;
        const isMature = timeRemaining <= bufferMs;

        console.log(`[REAL-TIME] Stake ${stakeId} maturity check:`, {
          timeRemaining,
          bufferMs,
          isMature,
          endDate: stake.endDate
        });

        if (isMature) {
          // Find the stake item in the DOM
          const stakeItem = document.querySelector(`[data-stake-id="${stakeId}"]`);
          if (stakeItem) {
            // Update the button from "Unlock" to "Redeem"
            const actionsDiv = stakeItem.querySelector('.actions');
            if (actionsDiv) {
              actionsDiv.innerHTML = `<button class="btn buy" onclick="stakeRedeem('${stakeId}')">Redeem</button>`;
              console.log(`[REAL-TIME] Updated button for stake ${stakeId} to "Redeem"`);
            }

            // Update the badge from "Maturing Soon" to "Matured"
            const badge = stakeItem.querySelector('.badge.soon');
            if (badge) {
              badge.className = 'badge mature';
              badge.textContent = 'Matured';
              console.log(`[REAL-TIME] Updated badge for stake ${stakeId} to "Matured"`);
            }

            // Move stake to ready section after a short delay
            setTimeout(() => {
              console.log(`[REAL-TIME] Moving stake ${stakeId} to ready section...`);
              refreshStakes(); // Full refresh to move between sections
            }, 2000);
          }
        }

      } catch (error) {
        console.error('[REAL-TIME] Error updating stake:', error);
        // Fallback to full refresh
        setTimeout(() => {
          refreshStakes();
        }, 1000);
      }
    };

    // SIMPLE DIRECT APPROACH: Check every second and move stakes as needed
    setInterval(() => {
      // Find all stakes with READY! countdown in the active section
      const activeSection = document.getElementById('ltActiveList');
      const readySection = document.getElementById('ltReadyList');
      const readyBlock = document.getElementById('ltReadyBlock');

      if (!activeSection || !readySection) return;

      const readyStakesInActiveSection = activeSection.querySelectorAll('.stake-item');
      let movedAny = false;

      readyStakesInActiveSection.forEach(stakeItem => {
        const countdown = stakeItem.querySelector('.countdown');
        const stakeId = stakeItem.dataset.stakeId;

        if (countdown && countdown.textContent === 'READY!' && stakeId) {
          console.log(`[DIRECT-MOVE] Moving stake ${stakeId} from Active to Ready section`);

          // Update the button to Redeem
          const actionsDiv = stakeItem.querySelector('.actions');
          if (actionsDiv) {
            actionsDiv.innerHTML = `<button class="btn buy" onclick="stakeRedeem('${stakeId}')">üí∞ Redeem</button>`;
          }

          // Update badge to Matured
          const badge = stakeItem.querySelector('.badge.soon');
          if (badge) {
            badge.className = 'badge mature';
            badge.textContent = 'Matured';
          }

          // Move the entire stake item to ready section
          readySection.appendChild(stakeItem);
          movedAny = true;

          console.log(`[DIRECT-MOVE] ‚úÖ Moved stake ${stakeId} to Ready section with Redeem button`);
        }
      });

      // Show ready block if we moved any stakes
      if (movedAny && readyBlock) {
        readyBlock.style.display = 'block';
      }

    }, 1000); // Check every second

    // Also check immediately when page loads
    setTimeout(() => {
      if (document.querySelector('.stake-item')) {
        updateAllStakeButtons();
      }
    }, 3000);

    // NEW badge functionality removed for simplicity

    // Add a direct button update function that can be called from console
    window.forceUpdateButtons = function () {
      console.log('[FORCE-UPDATE] Checking all stakes for immediate button updates...');

      document.querySelectorAll('.stake-item').forEach(stakeItem => {
        const stakeId = stakeItem.dataset.stakeId;
        const countdownEl = stakeItem.querySelector('.countdown');
        const actionsDiv = stakeItem.querySelector('.actions');
        const badge = stakeItem.querySelector('.badge');

        if (countdownEl && actionsDiv && stakeId) {
          const isReady = countdownEl.textContent === 'READY!';

          console.log(`[FORCE-UPDATE] Stake ${stakeId}: countdown="${countdownEl.textContent}", isReady=${isReady}`);

          if (isReady) {
            // Force update to redeem button
            actionsDiv.innerHTML = `<button class="btn buy" onclick="stakeRedeem('${stakeId}')">Redeem</button>`;
            if (badge && badge.classList.contains('soon')) {
              badge.className = 'badge mature';
              badge.textContent = 'Matured';
            }
            console.log(`[FORCE-UPDATE] ‚úÖ Updated ${stakeId} to REDEEM button`);
          } else {
            // Ensure it's unlock button
            actionsDiv.innerHTML = `<button class="btn" onclick="stakeUnstake('${stakeId}')">Unlock</button>`;
            console.log(`[FORCE-UPDATE] ‚è≥ Confirmed ${stakeId} has UNLOCK button`);
          }
        }
      });
    };

    // Add function to manually move ready stakes to correct section
    window.fixStakeSections = function () {
      console.log('[FIX-SECTIONS] Manually checking and moving stakes to correct sections...');

      // Force a complete refresh of stake data and sections
      if (typeof stakeLoadInfo === 'function') {
        stakeLoadInfo().then(() => {
          console.log('[FIX-SECTIONS] ‚úÖ Stake sections refreshed');

          // Also force button updates after refresh
          setTimeout(() => {
            forceUpdateButtons();
          }, 1000);
        }).catch(e => {
          console.warn('[FIX-SECTIONS] Refresh failed:', e);
        });
      }
    };


  })();
</script>