<!DOCTYPE html>
<html lang="en">
<!-- VERSION: 2025-10-08-BONUS-FIX - Stats page with correct +12%/18%/25%/45% bonuses -->

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>WALDOcoin Dashboard - UPDATED OCT 8 2025</title>
  <link href="https://cdn.jsdelivr.net/npm/chart.js/dist/Chart.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
  <style>
    html,
    body {
      font-family: 'Inter', sans-serif;
      background-image: url("https://waldocoin.live/wp-content/uploads/2025/05/1737843965137.jpg") !important;
      background-color: #000 !important;
      background-size: 200px 200px !important;
      background-repeat: repeat !important;
      background-attachment: fixed !important;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow-y: auto !important;
      overflow-x: hidden;
    }

    .dashboard-title-card {
      background: #000;
      border-radius: 18px;
      box-shadow: 0 0 22px #25c2a0;
      max-width: 650px;
      margin: 32px auto 18px auto;
      padding: 34px 16px 20px 16px;
      text-align: center;
      z-index: 10;
      position: relative;
    }

    .dashboard-title {
      font-size: 2.7rem;
      color: #25c2a0;
      font-weight: 900;
      letter-spacing: 1.5px;
      margin: 0 0 8px 0;
      text-shadow: 0 2px 24px #25c2a099, 0 1px 0 #fff;
    }

    .dashboard-subtitle {
      color: #fff;
      font-size: 1.18rem;
      font-weight: 400;
      margin-bottom: 0;
      opacity: 0.8;
      text-shadow: 0 1px 8px #25c2a055;
    }

    .instruction-card {
      background: #111 !important;
      color: #fff;
      border-radius: 14px;
      box-shadow: 0 0 18px #25c2a044;
      max-width: 600px;
      margin: 0 auto 32px auto;
      padding: 28px 24px;
      text-align: center;
      font-size: 1.15rem;
      position: relative;
      z-index: 9;
    }

    .instruction-card h2 {
      color: #25c2a0;
      margin-top: 0;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .instruction-card ul {
      padding: 0;
      margin: 0;
      list-style: none;
    }

    .instruction-card li {
      margin-bottom: 12px;
      line-height: 1.7;
      font-size: 1.1em;
    }

    /* Grid Container for Cards */
    .container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 30px;
      margin: 0 auto;
      padding: 40px 10px;
      box-sizing: border-box;
      max-width: 1400px;
      width: 100%;
    }

    /* Responsive! */
    .dashboard-title-card,
    .instruction-card {
      max-width: 98vw;
      padding-left: 8px;
      padding-right: 8px;
    }

    /* Navigation responsive */
    @media (max-width: 768px) {
      .nav-header {
        flex-direction: column !important;
        gap: 15px !important;
        padding: 15px !important;
      }

      .nav-links {
        flex-wrap: wrap !important;
        justify-content: center !important;
        gap: 8px !important;
      }

      .nav-link {
        font-size: 0.8rem !important;
        padding: 6px 12px !important;
      }

      .disconnect-button {
        padding: 6px 12px !important;
        font-size: 0.8rem !important;
      }
    }

    .twitter-link-container {
      max-width: 96vw;
    }


    /* Card Styles */
    .card {
      background: #111;
      color: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
      animation: fadeInUp 0.8s ease;
      position: relative;
    }

    .big-card,
    .dao-voting-card {
      grid-column: 1 / -1;
    }

    .reward-logic-table {
      grid-column: 1 / -1;
      width: 100%;
      margin: 0;
      padding: 0;
      /* or padding: 0 18px; if you want some space inside */
      box-sizing: border-box;
    }

    .reward-logic-table table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
    }

    .reward-logic-table th,
    .reward-logic-table td {
      padding: 14px 8px;
      text-align: center;
      white-space: nowrap;
      font-size: 1.1em;
      /* Optional: */
      /* border-bottom: 1px solid #333; */
    }

    /* Stretch each column equally */
    .reward-logic-table th,
    .reward-logic-table td {
      width: 12.5%;
      /* 8 columns: 100%/8 = 12.5% */
    }

    /* Optionally, let first column a bit smaller and others bigger */
    .reward-logic-table th:first-child,
    .reward-logic-table td:first-child {
      width: 10%;
    }

    .reward-logic-table th:last-child,
    .reward-logic-table td:last-child {
      width: 16%;
    }

    .tooltip-wrapper {
      position: relative;
      display: inline-block;
    }

    .tooltip-icon {
      background: #25c2a0;
      color: black;
      font-size: 15px;
      font-weight: bold;
      padding: 2px 7px;
      border-radius: 50%;
      cursor: pointer;
      margin-left: 8px;
    }

    .tooltip-text {
      visibility: hidden;
      opacity: 0;
      width: 240px;
      background-color: #111;
      color: #25c2a0;
      text-align: center;
      border-radius: 6px;
      padding: 10px 14px;
      position: absolute;
      z-index: 10;
      left: 50%;
      top: 120%;
      margin-left: -120px;
      transition: opacity 0.3s, visibility 0.3s;
      font-size: 1.03em;
      box-shadow: 0 0 10px #25c2a0;
    }

    /* Show on hover */
    .tooltip-wrapper:hover .tooltip-text,
    .tooltip-wrapper:focus-within .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    /* Twitter Link (Input + Button) */
    .twitter-link-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      margin: 28px auto 18px auto;
      width: 100%;
      max-width: 350px;
    }

    .input-style {
      width: 100%;
      padding: 13px 16px;
      border-radius: 8px;
      background: #222;
      color: white;
      border: 1.5px solid #25c2a0;
      font-size: 17px;
      font-weight: 600;
      box-shadow: 0 0 8px #25c2a022;
    }

    .button-style {
      width: 100%;
      max-width: 360px;
      padding: 14px 0;
      border-radius: 8px;
      background: linear-gradient(90deg, #25c2a0 30%, #ff2626 100%);
      color: #fff;
      font-weight: bold;
      font-size: 18px;
      border: none;
      margin: 0;
      cursor: pointer;
      box-shadow: 0 0 8px #25c2a0bb;
      transition: background 0.2s, box-shadow 0.2s;
      letter-spacing: 1px;
    }

    .button-style:hover {
      background: linear-gradient(90deg, #1ba97b 20%, #ff5252 100%);
      box-shadow: 0 0 16px #25c2a0;
    }

    /* General Element Styles */
    .card h1,
    .card h2,
    .card h3 {
      color: #25c2a0;
      text-align: center;
      font-weight: bold;
    }

    .level-title {
      margin: 10px 0;
      font-weight: bold;
      color: #25c2a0;
    }

    .level-title.level-1 {
      color: #ff2626;
    }

    .level-title.level-2 {
      color: #298cf5;
    }

    .level-title.level-3 {
      color: #ff930e;
    }

    .level-title.level-4 {
      color: #63f707;
    }

    .level-title.level-5 {
      color: rgb(255, 196, 0);
    }

    .level-icon {
      width: 80px;
      height: auto;
      display: block;
      margin: 10px auto;
      border-radius: 8px;
    }

    #userLevelIcon {
      width: 100px;
      height: auto;
      margin: 10px auto;
      display: block;
    }

    .wallet-address {
      text-align: center;
      margin-bottom: 30px;
    }

    .disconnect-btn,
    .connect-btn {
      display: block;
      margin: 0 auto 20px;
      padding: 8px 18px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      color: white;
    }

    .disconnect-btn {
      background: red;
    }

    .connect-btn {
      background: #25c2a0;
      box-shadow: 0 0 10px rgba(37, 194, 160, 0.3);
    }

    .connect-btn:hover {
      background: #1ea085;
      box-shadow: 0 0 15px rgba(37, 194, 160, 0.5);
    }

    /* XUMM Modal Styles */
    .xumm-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .xumm-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      cursor: pointer;
    }

    .xumm-content {
      position: relative;
      background: #111;
      border-radius: 15px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 0 30px rgba(37, 194, 160, 0.3);
      border: 1px solid #25c2a0;
    }



    #xummTitle {
      color: #25c2a0;
      margin: 0 0 20px 0;
      font-size: 1.4em;
    }

    .xumm-hint {
      color: #ccc;
      margin: 15px 0 0 0;
      font-size: 0.9em;
    }

    .xumm-loader {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #333;
      border-top: 3px solid #25c2a0;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .battle-memes-container {
      display: flex;
      justify-content: space-around;
      gap: 30px;
      flex-wrap: wrap;
    }

    .battle-memes-container .flex-item {
      flex: 1;
      min-width: 180px;
      max-width: 280px;
      background: #191919;
      border-radius: 12px;
      padding: 16px;
      margin: 0 12px;
      box-shadow: 0 0 12px #222;
      text-align: center;
    }

    @media (max-width: 900px) {}

    .battle-memes-container {
      flex-direction: column;
      align-items: center;
    }

    .battle-memes-container .flex-item {
      max-width: 95vw;
      margin: 10px 0;
    }

    .battle-timer {
      margin-top: 20px;
      font-weight: bold;
      font-size: 2.2rem;
      color: #25c2a0;
      text-align: center;
      letter-spacing: 1px;
      text-shadow: 0 0 14px #25c2a088, 0 2px 0 #000;
      animation: pulseTimer 2s infinite;
    }

    @keyframes pulseTimer {
      0% {
        color: #25c2a0;
      }

      50% {
        color: #fff;
      }

      100% {
        color: #25c2a0;
      }
    }

    .battle-result {
      font-weight: bold;
      font-size: 16px;
      color: gold;
      margin-top: 10px;
    }

    .battle-notification {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #fb2f2f;
      color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(251, 47, 47, 0.6);
      z-index: 999;
      animation: pulse 2s infinite;
      cursor: pointer;
    }

    .notification-banner {
      background: #111;
      color: #25c2a0;
      text-align: center;
      padding: 16px 0;
      border-radius: 10px;
      margin-bottom: 20px;
      font-size: 1.18rem;
      font-weight: 600;
    }

    /* Miscellaneous Styles */
    .progress-bar {
      width: 100%;
      height: 12px;
    }

    #levelProgress {
      width: 100%;
      height: 20px;
    }

    /* max-width: 90%; */
    /* max-height: 90%; */
    /* border-radius: 12px; */
    /* box-shadow: 0 0 20px #fb2f2f; */
    .dao-voting-card {
      box-shadow: 0 0 12px #ffcc00;
    }

    .margin-top-0 {
      margin-top: 0;
    }

    .margin-top-20 {
      margin-top: 20px;
    }

    .meme-thumb {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 8px;
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .meme-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 0 10px #fb2f2f;
    }

    .waldo-promo-img {
      width: 100%;
      border-radius: 8px;
    }

    .waldo-total-earned-display {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
    }

    .pagination {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-top: 15px;
    }

    .pagination button {
      padding: 5px 10px;
      border: none;
      background: transparent;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }

    .meme-score {
      font-size: 60px;
      font-weight: bold;
      color: #25c2a0;
      transition: all 0.5s;
    }

    /* Enhanced Meme Score Card with Dynamic Backgrounds */
    #memeScoreCard {
      position: relative;
      overflow: hidden;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background-image 0.8s ease-in-out;
    }

    #memeScoreCard::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(17, 17, 17, 0.85);
      /* Dark overlay for readability */
      z-index: 1;
    }

    #memeScoreCard>* {
      position: relative;
      z-index: 2;
    }

    .meme-score-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 120px;
      margin: 20px 0;
    }

    .meme-score-enhanced {
      font-size: 120px;
      font-weight: 900;
      color: #25c2a0;
      text-align: center;
      margin: 0;
      text-shadow:
        0 0 20px #25c2a0,
        0 0 40px #25c2a0,
        2px 2px 4px rgba(0, 0, 0, 0.8);
      transition: all 0.6s ease;
      line-height: 1;
    }

    /* Level-specific background classes */
    .level-bg-1 {
      background-image: url("https://waldocoin.live/wp-content/uploads/2025/04/1737843965114.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
    }

    .level-bg-2 {
      background-image: url("https://waldocoin.live/wp-content/uploads/2025/03/1737843965414.jpeg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
    }

    .level-bg-3 {
      background-image: url("https://waldocoin.live/wp-content/uploads/2025/03/F.A.F.O.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
    }

    .level-bg-4 {
      background-image: url("https://waldocoin.live/wp-content/uploads/2025/04/WhatsApp-Image-2025-04-03-at-22.52.10.jpeg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
    }

    .level-bg-5 {
      background-image: url("https://waldocoin.live/wp-content/uploads/2025/04/WhatsApp-Image-2025-04-03-at-22.53.38.jpeg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
    }

    /* Add overlay to make text readable over background images */
    .level-bg-1::before,
    .level-bg-2::before,
    .level-bg-3::before,
    .level-bg-4::before,
    .level-bg-5::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 12px;
      z-index: 1;
    }

    /* Ensure content appears above the overlay */
    .level-bg-1>*,
    .level-bg-2>*,
    .level-bg-3>*,
    .level-bg-4>*,
    .level-bg-5>* {
      position: relative;
      z-index: 2;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .meme-score-enhanced {
        font-size: 80px;
      }

      .meme-score-container {
        min-height: 100px;
      }
    }

    @media (max-width: 480px) {
      .meme-score-enhanced {
        font-size: 60px;
      }

      .meme-score-container {
        min-height: 80px;
      }
    }

    /* Pulse animation for high scores */
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.05);
        opacity: 0.8;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .xp-stats-card {
      background: #111;
      color: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
    }

    .flex-column-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .centered-flex-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .overflow-auto {
      overflow-x: auto;
    }

    .activity-feed,
    .leaderboard-list {
      list-style: none;
      padding: 0;
      font-size: 16px;
    }

    .leaderboard-container {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 20px;
    }

    .flex-item {
      flex: 1;
      min-width: 300px;
    }

    .info-text {
      font-size: 14px;
      color: #aaa;
      margin-top: 10px;
    }

    .toast {
      background: #191919;
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      box-shadow: 0 0 8px #25c2a055;
      margin-top: 12px;
      font-weight: 600;
      font-size: 1.09em;
    }

    .hidden {
      display: none !important;
    }

    .margin-bottom-10 {
      margin-bottom: 10px;
    }

    .dismiss-btn {
      margin-left: 20px;
      background: transparent;
      border: 1px solid #25c2a0;
      color: #25c2a0;
      padding: 4px 10px;
      border-radius: 6px;
      cursor: pointer;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(40px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulseBanner {
      0% {
        box-shadow: 0 0 10px #25c2a0;
      }

      50% {
        box-shadow: 0 0 20px #25c2a0;
      }

      100% {
        box-shadow: 0 0 10px #25c2a0;
      }
    }

    /* Make the table fill the card and space headers/cells */
    .card table,
    .reward-logic-table table {
      width: 100%;
      table-layout: auto;
      /* Let columns size naturally */
      border-collapse: separate;
      border-spacing: 0;
    }

    .card th,
    .card td,
    .reward-logic-table th,
    .reward-logic-table td {
      padding: 14px 12px;
      /* Adds horizontal and vertical space */
      text-align: center;
      vertical-align: middle;
      font-size: 1.07em;
      white-space: nowrap;
    }

    .card th,
    .reward-logic-table th {
      background: #161616;
      color: #25c2a0;
      font-weight: 700;
      font-size: 1.11em;
      letter-spacing: 0.03em;
      border-bottom: 2px solid #222;
    }

    .card td,
    .reward-logic-table td {
      border-bottom: 1px solid #232323;
    }

    .card tr:last-child td,
    .reward-logic-table tr:last-child td {
      border-bottom: none;
    }

    /* Responsive: Let table scroll horizontally on small screens */
    .overflow-auto {
      overflow-x: auto;
      width: 100%;
    }

    /* Optional: Make Thumbnail column wider */
    .card td:first-child,
    .card th:first-child {
      min-width: 90px;
    }

    .battle-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      align-items: center;
      margin-bottom: 24px;
    }

    @media (max-width: 700px) {
      .battle-actions {
        flex-direction: column;
        align-items: stretch;
      }
    }

    #claimBlock button {
      min-width: 150px;
    }

    /* Battle Controls Styling */
    .battle-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 20px;
      background: #191919;
      border-radius: 12px;
      margin: 0 20px;
    }

    .battle-controls input {
      width: 100%;
      max-width: 400px;
    }

    .battle-controls button {
      width: 100%;
      max-width: 300px;
    }

    /* === STAKING ZONE STYLES === */
    .staking-zone {
      max-width: 1000px;
      margin: 0 auto 30px auto;
      padding: 25px;
    }

    .staking-zone-bar {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      margin: 30px 20px;
      padding: 25px;
      width: calc(100% - 40px);
      box-sizing: border-box;
      max-width: none;
      color: #fff;
    }

    .staking-zone-bar h2,
    .staking-zone-bar h3,
    .staking-zone-bar p,
    .staking-zone-bar span,
    .staking-zone-bar div,
    .staking-zone-bar th,
    .staking-zone-bar td {
      color: #fff !important;
    }

    .staking-zone-bar .apy-banner-title,
    .staking-zone-bar .apy-rate-text,
    .staking-zone-bar .staking-stat-label {
      color: #fff !important;
    }

    .staking-zone-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      margin: 0;
      font-size: 1.4em;
      font-weight: 600;
      color: #fff;
      transition: color 0.3s ease;
    }

    .staking-zone-header:hover {
      color: #25c2a0;
    }

    .staking-zone-content {
      margin-top: 20px;
    }

    .staking-table-container {
      margin-bottom: 20px;
    }

    .staking-table-wrapper {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    /* === LONG TERM BONUS TABLE FULL WIDTH === */
    #longTermBonusTable {
      width: 100%;
      table-layout: fixed;
      border-collapse: separate;
      border-spacing: 0;
      background: #222;
      border-radius: 8px;
      overflow: hidden;
    }

    #longTermBonusTable th {
      background: #333;
      color: #25c2a0;
      padding: 12px 8px;
      text-align: center;
      font-weight: bold;
      border-bottom: 2px solid #25c2a0;
    }

    #longTermBonusTable td {
      padding: 12px 8px;
      text-align: center;
      border-bottom: 1px solid #333;
      color: #ccc;
    }

    #longTermBonusTable tbody tr:hover {
      background: #2a2a2a;
    }

    /* Column width distribution for better spacing */
    #longTermBonusTable th:nth-child(1) {
      width: 12%;
    }

    /* Position ID */
    #longTermBonusTable th:nth-child(2) {
      width: 18%;
    }

    /* Amount */
    #longTermBonusTable th:nth-child(3) {
      width: 12%;
    }

    /* Duration */
    #longTermBonusTable th:nth-child(4) {
      width: 12%;
    }

    /* Bonus % */
    #longTermBonusTable th:nth-child(5) {
      width: 18%;
    }

    /* Current Rewards */
    #longTermBonusTable th:nth-child(6) {
      width: 14%;
    }

    /* Status */
    #longTermBonusTable th:nth-child(7) {
      width: 14%;
    }

    /* Action */

    /* Mobile responsive for Long Term Bonus table */
    @media (max-width: 768px) {
      #longTermBonusTable {
        font-size: 12px;
      }

      #longTermBonusTable th,
      #longTermBonusTable td {
        padding: 8px 4px;
      }

      /* Adjust column widths for mobile */
      #longTermBonusTable th:nth-child(1) {
        width: 10%;
      }

      /* Position ID - smaller */
      #longTermBonusTable th:nth-child(2) {
        width: 20%;
      }

      /* Amount - bigger */
      #longTermBonusTable th:nth-child(3) {
        width: 10%;
      }

      /* Duration - smaller */
      #longTermBonusTable th:nth-child(4) {
        width: 10%;
      }

      /* Bonus % - smaller */
      #longTermBonusTable th:nth-child(5) {
        width: 20%;
      }

      /* Current Rewards - bigger */
      #longTermBonusTable th:nth-child(6) {
        width: 15%;
      }

      /* Status */
      #longTermBonusTable th:nth-child(7) {
        width: 15%;
      }

      /* Action */
    }

    /* Empty state styling for Long Term Bonus table */
    .staking-positions-empty {
      text-align: center;
      color: #666;
      padding: 30px 20px;
      font-style: italic;
      background: #1a1a1a;
    }

    /* === ENHANCED STAKING TABLE STYLES === */
    .staking-zone-bar #stakingTable {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      background: #1a1a1a;
      border-radius: 8px;
      overflow: hidden;
    }

    .staking-zone-bar #stakingTable th {
      background: #161616;
      color: #25c2a0 !important;
      font-weight: 700;
      font-size: 1.1em;
      padding: 16px 12px;
      text-align: center;
      border-bottom: 2px solid #333;
    }

    .staking-zone-bar #stakingTable td {
      color: #fff !important;
      padding: 14px 12px;
      text-align: center;
      border-bottom: 1px solid #333;
      background: #1a1a1a;
    }

    .staking-zone-bar #stakingTable tr:hover td {
      background: #222;
    }

    .staking-zone-bar .staking-positions-empty {
      color: #888 !important;
      font-style: italic;
      padding: 30px !important;
      text-align: center;
    }

    .staking-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }

    .staking-summary-card {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }

    .toggle-icon {
      font-size: 1.2em;
      transition: transform 0.3s ease;
    }

    /* === WALDO PROMO STYLES === */
    .waldo-promo-content {
      background: linear-gradient(135deg, #25c2a0 0%, #00ff88 100%);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      color: #000;
    }

    .waldo-promo-icon {
      font-size: 2.5em;
      margin-bottom: 15px;
    }

    .waldo-promo-title {
      margin: 0;
      font-size: 1.8em;
      font-weight: bold;
    }

    .waldo-promo-subtitle {
      font-size: 1.1em;
      margin-top: 10px;
      opacity: 0.8;
    }

    /* === CONTENT LAYOUT STYLES === */
    .content-center {
      text-align: center;
      margin-top: 10px;
    }

    .content-center-padded {
      text-align: center;
      padding: 20px 0;
    }

    .large-number {
      font-size: 2.5em;
      font-weight: bold;
      margin: 15px 0;
    }

    .large-number-green {
      color: #00ff88;
    }

    .large-number-yellow {
      color: #ffd93d;
    }

    .subtitle-text {
      color: #aaa;
      font-size: 1.1em;
      margin-bottom: 15px;
    }

    .level-info {
      color: #25c2a0;
      font-weight: bold;
    }

    .next-level-info {
      color: #aaa;
      font-size: 0.9em;
      margin-top: 5px;
    }

    .hidden-input {
      display: none;
    }

    .chart-container {
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px 0;
    }

    .chart-canvas {
      max-width: 100%;
    }

    .activity-feed-padded {
      padding: 20px 0;
    }

    /* === APY BANNER STYLES === */
    .apy-banner {
      background: #222;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
    }

    .apy-banner-title {
      color: #25c2a0;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .apy-banner-rates {
      display: flex;
      justify-content: space-around;
      font-size: 0.9em;
    }

    .apy-rate-text {
      color: #fff;
    }

    .apy-rate-green {
      color: #25c2a0;
    }

    .apy-rate-bright-green {
      color: #00ff88;
    }

    .apy-warning {
      font-size: 0.8em;
      color: #aaa;
      margin-top: 5px;
    }

    /* === STAKING STATS STYLES === */
    .staking-stats {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
    }

    .staking-stat-item {
      text-align: center;
    }

    .staking-stat-value {
      font-weight: bold;
    }

    .staking-stat-green {
      color: #25c2a0;
    }

    .staking-stat-bright-green {
      color: #00ff88;
    }

    .staking-stat-label {
      font-size: 0.85em;
      color: #aaa;
    }

    .staking-positions-empty {
      color: #aaa;
      text-align: center;
      padding: 20px;
    }

    .staking-button-container {
      margin-top: 15px;
      text-align: center;
    }

    /* === WALLET CONNECTION SCREEN STYLES === */
    .wallet-connection-screen {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    /* === LOADER STYLES === */
    .waldo-loader {
      position: fixed;
      z-index: 999999;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .waldo-loader-text {
      color: #25c2a0;
      font-size: 2.2em;
      font-weight: bold;
      letter-spacing: 2px;
    }

    /* === INSTRUCTION CARD STYLES === */
    .instruction-cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .instruction-card-content {
      background: #222;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 10px;
    }

    .instruction-card-warning {
      background: #ffd93d20;
      padding: 8px;
      border-radius: 6px;
      margin-top: 10px;
      text-align: center;
    }

    .instruction-subtitle {
      font-size: 0.85em;
      color: #aaa;
      margin-bottom: 10px;
    }

    .tier-grid {
      display: grid;
      gap: 8px;
    }

    .tier-item {
      background: #25c2a020;
      padding: 8px;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
    }

    .tier-item-blue {
      background: rgba(79, 195, 247, 0.5);
    }

    .tier-item-yellow {
      background: rgba(255, 217, 61, 0.5);
    }

    .tier-item-purple {
      background: rgba(156, 39, 176, 0.5);
    }

    .process-grid {
      display: grid;
      gap: 8px;
      font-size: 0.9em;
    }

    .process-step {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .process-number {
      background: #25c2a0;
      color: #000;
      padding: 4px 8px;
      border-radius: 50%;
      font-weight: bold;
      font-size: 0.8em;
      min-width: 24px;
      text-align: center;
    }

    .process-number-yellow {
      background: #ffd93d;
    }

    .warning-box {
      background: #ff6b6b20;
      padding: 8px;
      border-radius: 6px;
      margin-top: 12px;
      text-align: center;
    }

    .example-title {
      color: #ffd93d;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .example-card {
      background: #222;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .hidden {
      display: none;
    }

    .text-red {
      color: #ff6b6b;
    }

    .text-green {
      color: #25c2a0;
    }

    .text-yellow {
      color: #ffd93d;
    }

    .text-blue {
      color: #4fc3f7;
    }

    .text-purple {
      color: #9c27b0;
    }

    .text-gray {
      color: #ccc;
    }

    .text-light-gray {
      color: #aaa;
    }

    .text-dark-gray {
      color: #666;
    }

    .font-bold {
      font-weight: bold;
    }

    .font-small {
      font-size: 0.85em;
    }

    .font-tiny {
      font-size: 0.75em;
    }

    .margin-bottom-5 {
      margin-bottom: 5px;
    }

    .margin-bottom-6 {
      margin-bottom: 6px;
    }

    .margin-bottom-8 {
      margin-bottom: 8px;
    }

    .margin-bottom-10 {
      margin-bottom: 10px;
    }

    .margin-top-5 {
      margin-top: 5px;
    }

    .margin-top-10 {
      margin-top: 10px;
    }

    .padding-20 {
      padding: 20px;
    }

    /* === XP MULTIPLIERS STYLES === */
    .xp-multipliers-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 15px 0;
    }

    .xp-multiplier-card {
      background: #222;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .xp-multiplier-card.active {
      border-color: #25c2a0;
      background: #1a2f1a;
    }

    .xp-multiplier-card.inactive {
      opacity: 0.6;
      background: #1a1a1a;
    }

    .xp-multiplier-value {
      font-size: 1.5em;
      font-weight: bold;
    }

    .xp-multiplier-value-green {
      color: #25c2a0;
    }

    .xp-multiplier-value-red {
      color: #ff6b6b;
    }

    .xp-multiplier-value-yellow {
      color: #ffd93d;
    }

    .xp-multiplier-value-light-green {
      color: #6bcf7f;
    }

    .xp-multiplier-status {
      font-size: 0.8em;
      margin-top: 8px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
    }

    .xp-multiplier-status.active {
      background: #25c2a0;
      color: white;
    }

    .xp-multiplier-status.inactive {
      background: #666;
      color: #ccc;
    }

    .xp-multiplier-status.loading {
      background: #444;
      color: #888;
    }

    .xp-multiplier-status.error {
      background: #ff6b6b;
      color: white;
    }

    .xp-multiplier-label {
      font-size: 0.9em;
      color: #aaa;
    }

    .xp-multiplier-description {
      font-size: 0.8em;
      color: #666;
      margin-top: 5px;
    }

    .xp-tips-box {
      background: #191919;
      padding: 12px;
      border-radius: 8px;
      margin-top: 15px;
      text-align: center;
    }

    .xp-tips-title {
      color: #25c2a0;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .xp-tips-content {
      font-size: 0.9em;
      color: #ccc;
    }

    /* === XP BREAKDOWN STYLES === */
    .xp-breakdown-container {
      padding: 15px 0;
    }

    .xp-breakdown-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .xp-breakdown-row:last-child {
      margin-bottom: 0;
    }

    .xp-breakdown-label {
      color: #fff;
      font-weight: 500;
    }

    .xp-breakdown-value {
      color: #25c2a0;
      font-weight: bold;
    }

    .xp-breakdown-value-yellow {
      color: #ffd93d;
      font-weight: bold;
    }

    /* === INSTRUCTION CARDS SPACING === */
    .instruction-cards-spacing {
      margin: 30px 0;
    }

    /* === FULL-WIDTH INSTRUCTION CARDS === */
    .instruction-cards-full-width {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 20px;
      margin: 30px 20px;
      width: calc(100% - 40px);
      box-sizing: border-box;
    }

    /* When inside staking zone, adjust margins */
    .staking-zone-content .instruction-cards-full-width {
      margin: 20px 0 30px 0;
      width: 100%;
    }

    .instruction-card-full {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 25px;
      color: #fff;
    }

    .instruction-card-full h2 {
      margin: 0 0 20px 0;
      color: #fff;
      font-size: 1.4em;
    }

    @media (max-width: 768px) {
      .instruction-cards-full-width {
        grid-template-columns: 1fr;
        margin: 30px 10px;
        width: calc(100% - 20px);
      }
    }

    /* === REFERRAL BENEFITS STYLES === */
    .referral-benefits {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .benefit-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: rgba(37, 194, 160, 0.1);
      border-radius: 6px;
    }

    .benefit-icon {
      font-size: 1.2em;
    }

    .benefit-text {
      color: #fff;
      font-size: 0.9em;
    }

    /* === ACTIVITY FEED STYLES === */
    .activity-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 0;
      border-bottom: 1px solid #333;
    }

    .activity-item:last-child {
      border-bottom: none;
    }

    .activity-icon {
      font-size: 1.1em;
      min-width: 20px;
    }

    .activity-text {
      flex: 1;
      color: #fff;
      font-size: 0.9em;
    }

    .activity-time {
      color: #888;
      font-size: 0.8em;
    }

    .activity-footer {
      margin-top: 15px;
      text-align: center;
    }

    @media (max-width: 768px) {
      .referral-benefits {
        gap: 8px;
      }
    }

    /* === MOVING LEVEL PROGRESS STYLES === */
    .level-title-centered {
      text-align: center;
      margin: 10px 0 20px 0;
      color: #25c2a0;
      font-weight: 600;
      font-size: 1.1em;
    }

    .level-progress-container {
      position: relative;
      margin: 20px 30px;
      /* Add side margins to shorten the bar */
      overflow: visible;
      padding-top: 30px;
    }

    .level-progress-indicator {
      position: absolute;
      top: -30px;
      left: 0%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: left 0.5s ease;
      z-index: 5;
      max-width: 60px;
    }

    .level-icon-moving {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 1px solid #25c2a0;
      background: #1a1a1a;
      padding: 1px;
      margin-bottom: 3px;
      object-fit: cover;
    }

    .xp-next-level-moving {
      background: rgba(37, 194, 160, 0.9);
      color: #fff;
      padding: 3px 6px;
      border-radius: 8px;
      font-size: 0.7em;
      font-weight: 600;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(37, 194, 160, 0.3);
      min-width: 60px;
      text-align: center;
    }

    #levelProgress {
      width: 100%;
      height: 20px;
      border-radius: 10px;
      background: #333;
      border: none;
      overflow: hidden;
    }

    #levelProgress::-webkit-progress-bar {
      background: #333;
      border-radius: 10px;
    }

    #levelProgress::-webkit-progress-value {
      background: linear-gradient(90deg, #25c2a0, #00ff88);
      background-size: 200% 100%;
      border-radius: 10px;
      transition: width 0.5s ease;
      animation: progressShimmer 6s linear infinite;
    }

    #levelProgress::-moz-progress-bar {
      background: linear-gradient(90deg, #25c2a0, #00ff88);
      background-size: 200% 100%;
      border-radius: 10px;
      transition: width 0.5s ease;
      animation: progressShimmer 6s linear infinite;
    }

    @media (max-width: 768px) {
      .level-icon-moving {
        width: 20px;
        height: 20px;
      }

      .xp-next-level-moving {
        font-size: 0.65em;
        padding: 2px 4px;
        min-width: 50px;
      }

      .level-progress-indicator {
        top: -20px;
      }

      .level-progress-container {
        margin: 20px 20px;
        /* Smaller side margins on mobile */
      }
    }

    /* === REWARD TIERS & MY MEMES CARD === */
    .reward-tiers-section {
      margin-bottom: 30px;
      padding-bottom: 25px;
      border-bottom: 1px solid #333;
    }

    .reward-tiers-section h3,
    .my-memes-section h3 {
      color: #25c2a0;
      margin: 0 0 15px 0;

      /* Global keyframes and helper classes for progress/indicator */
      @keyframes progressShimmer {
        0% {
          background-position: 0% 0;
        }

        100% {
          background-position: -200% 0;
        }
      }

      .level-progress-indicator.pulse {
        animation: indicatorPulse 1.2s ease-out 1;
      }

      @keyframes indicatorPulse {
        0% {
          transform: translateX(-50%) scale(0.96);
          filter: drop-shadow(0 0 0 rgba(37, 194, 160, 0));
        }

        60% {
          transform: translateX(-50%) scale(1.06);
          filter: drop-shadow(0 0 8px rgba(37, 194, 160, 0.6));
        }

        100% {
          transform: translateX(-50%) scale(1);
          filter: drop-shadow(0 0 0 rgba(37, 194, 160, 0));
        }
      }

      font-size: 1.2em;
      font-weight: 600;
    }

    /* Eligibility card glow when eligible */
    #eligibilityCard.eligible {
      box-shadow: 0 0 18px rgba(37, 194, 160, 0.25), inset 0 0 12px rgba(37, 194, 160, 0.15);
      animation: eligGlow 3.5s ease-in-out infinite;
    }

    @keyframes eligGlow {

      0%,
      100% {
        box-shadow: 0 0 12px rgba(37, 194, 160, 0.18), inset 0 0 8px rgba(37, 194, 160, 0.10);
      }

      50% {
        box-shadow: 0 0 24px rgba(37, 194, 160, 0.35), inset 0 0 16px rgba(37, 194, 160, 0.18);
      }
    }

    /* Spark particle that travels with the indicator on milestone updates */
    .level-progress-indicator .spark {
      position: absolute;
      top: 10px;
      left: 0;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #00ff88;
      box-shadow: 0 0 8px rgba(0, 255, 136, 0.8);
      opacity: 0;
      transform: translateX(-8px) translateY(-6px) scale(0.8);
      animation: sparkFly 700ms ease-out forwards;
      pointer-events: none;
    }

    @keyframes sparkFly {
      0% {
        opacity: 0;
        transform: translateX(-8px) translateY(-6px) scale(0.8);
      }

      20% {
        opacity: 1;
      }

      100% {
        opacity: 0;
        transform: translateX(16px) translateY(6px) scale(0.9);
      }
    }


    .tiers-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 15px;
    }

    .tier-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .tier-card:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    .tier-1 {
      border-left: 3px solid #cd7f32;
    }

    .tier-2 {
      border-left: 3px solid #c0c0c0;
    }

    .tier-3 {
      border-left: 3px solid #ffd700;
    }

    .tier-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .tier-icon {
      font-size: 1.2em;
    }

    .tier-title {
      color: #fff;
      font-weight: 600;
    }

    .tier-requirements {
      color: #ccc;
      font-size: 0.9em;
      margin-bottom: 8px;
    }

    .tier-reward {
      color: #25c2a0;
      font-weight: 700;
      font-size: 1.1em;
    }

    .tier-multiplier-note {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: rgba(37, 194, 160, 0.1);
      padding: 10px;
      border-radius: 6px;
    }

    .multiplier-icon {
      color: #ffd93d;
      font-size: 1.1em;
    }

    .multiplier-text {
      color: #25c2a0;
      font-weight: 600;
      font-size: 0.9em;
    }

    .my-memes-section {
      margin-top: 25px;
    }

    .memes-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }

    .meme-stat {
      text-align: center;
      padding: 15px;
      background: rgba(37, 194, 160, 0.05);
      border-radius: 8px;
      border: 1px solid rgba(37, 194, 160, 0.2);
    }

    .stat-number {
      display: block;
      color: #25c2a0;
      font-size: 1.8em;
      font-weight: 700;
      margin-bottom: 5px;
    }

    .stat-label {
      color: #ccc;
      font-size: 0.9em;
    }

    .memes-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    @media (max-width: 768px) {
      .tiers-grid {
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .memes-summary {
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .memes-actions {
        flex-direction: column;
        gap: 8px;
      }
    }

    /* === SHORT TERM OPTION COLLAPSIBLE CARD === */
    .collapsible-container {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 25px;
      margin: 36px 0;
      /* Half inch spacing (36px â‰ˆ 0.5 inch) */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .collapsible-header {
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0 0 20px 0;
      padding: 0;
      transition: color 0.3s ease;
      color: #fff;
      font-size: 1.4em;
      font-weight: 600;
    }

    .collapsible-header:hover {
      color: #25c2a0;
    }

    .toggle-icon {
      font-size: 1.2em;
      transition: transform 0.3s ease;
      color: #25c2a0;
    }

    .toggle-icon.collapsed {
      transform: rotate(-90deg);
    }

    .collapsible-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: 0;
      padding: 0;
      margin: 0;
    }

    .collapsible-content.expanded {
      max-height: 2000px;
      padding: inherit;
      margin: inherit;
    }

    .collapsible-content .card {
      margin-bottom: 20px;
      background: #222;
      border: 1px solid #444;
    }

    .collapsible-content .card:last-child {
      margin-bottom: 0;
    }

    /* === AUTO-CONTINUE STAKING STYLES === */
    .auto-continue-explanation {
      margin: 20px 0;
      padding: 20px;
      background: rgba(37, 194, 160, 0.15);
      border-radius: 8px;
      border-left: 3px solid #25c2a0;
    }

    .auto-continue-step {
      display: flex;
      align-items: flex-start;
      margin-bottom: 15px;
      gap: 15px;
    }

    .auto-continue-step:last-child {
      margin-bottom: 0;
    }

    .step-number {
      background: #25c2a0;
      color: #000;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    .step-content {
      flex: 1;
    }

    .step-title {
      color: #25c2a0;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .step-description {
      color: #ccc;
      font-size: 0.9em;
      line-height: 1.4;
    }

    .tier-item-default {
      border-left: 3px solid #25c2a0;
      background: rgba(37, 194, 160, 0.3);
    }

    .text-small {
      display: block;
      font-size: 0.8em;
      color: #aaa;
      margin-top: 4px;
    }

    .duplicate-restrictions-secondary {
      margin-top: 15px;
    }

    /* === ENHANCED WALDO MERGED CARD === */
    .waldo-merged-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 25px;
      margin-top: 20px;
    }

    .waldo-section {
      background: rgba(37, 194, 160, 0.05);
      border: 1px solid rgba(37, 194, 160, 0.2);
      border-radius: 10px;
      padding: 20px;
      transition: all 0.3s ease;
      overflow: hidden;
      box-sizing: border-box;
    }

    .waldo-section:hover {
      background: rgba(37, 194, 160, 0.08);
      border-color: rgba(37, 194, 160, 0.3);
      transform: translateY(-2px);
    }

    .waldo-section-header {
      margin-bottom: 15px;
    }

    .waldo-section-title {
      margin: 0 0 8px 0;
      color: #25c2a0;
      font-size: 1.1em;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .waldo-section-divider {
      height: 2px;
      background: linear-gradient(90deg, #25c2a0, transparent);
      border-radius: 1px;
      width: 60px;
    }

    .waldo-section-content {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .waldo-value-details {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .value-detail-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }

    .value-label {
      color: #ccc;
      font-size: 0.9em;
    }

    .value-amount {
      color: #25c2a0;
      font-weight: 600;
    }

    .chart-container-enhanced {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      padding: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-sizing: border-box;
      max-width: 100%;
    }

    .trend-stats {
      display: flex;
      justify-content: flex-start;
      gap: 15px;
      padding-left: 0;
    }

    .trend-stat-item {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      min-width: 120px;
    }

    .trend-label {
      color: #ccc;
      font-size: 0.85em;
      margin-bottom: 4px;
    }

    .trend-value {
      font-weight: 600;
      font-size: 0.95em;
    }

    .trend-positive {
      color: #25c2a0;
    }

    .trend-negative {
      color: #ff6b6b;
    }

    @media (max-width: 768px) {
      .waldo-merged-container {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .trend-stats {
        flex-direction: column;
        gap: 10px;
      }
    }

    /* === STAKING PROCESS STYLES === */
    .staking-process-section {
      background: #222;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .staking-process-title {
      color: #25c2a0;
      margin-top: 0;
    }

    .staking-process-title-yellow {
      color: #ffd93d;
      margin-top: 0;
    }

    .staking-process-title-green {
      color: #00ff88;
      margin-top: 0;
    }

    .staking-process-step {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .staking-process-number {
      background: #25c2a0;
      color: #000;
      padding: 8px 12px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.8em;
    }

    .staking-process-number-yellow {
      background: #ffd93d;
    }

    .staking-process-text {
      flex: 1;
      color: #ccc;
    }

    .staking-tier-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }

    .staking-tier-card {
      padding: 10px;
      border-radius: 6px;
      text-align: center;
    }

    .staking-tier-card-green {
      background: #25c2a0d3;
    }

    .staking-tier-card-blue {
      background: #4fc2f7c1;
    }

    .staking-tier-card-yellow {
      background: #caa617f0;
    }

    .staking-tier-card-purple {
      background: #9b27b0e1;
    }

    .staking-tier-title {
      font-weight: bold;
    }

    .staking-tier-subtitle {
      color: #ccc;
      font-size: 0.9em;
    }

    .staking-example-section {
      background: #191919;
      padding: 15px;
      border-radius: 8px;
    }

    .staking-example-card {
      background: #222;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 10px;
    }

    .staking-example-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      font-size: 0.9em;
    }

    .staking-restrictions-box {
      background: #ff6b6b20;
      padding: 10px;
      border-radius: 6px;
      margin-top: 15px;
    }

    .staking-restrictions-title {
      color: #ff6b6b;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .staking-restrictions-text {
      font-size: 0.85em;
      color: #ccc;
    }

    .battle-history-container {
      display: none;
    }

    /* === MODAL STYLES === */
    .modal-container {
      display: none;
    }

    .modal-content {
      background: #111;
      padding: 30px;
      border-radius: 15px;
      max-width: 500px;
      margin: 50px auto;
      position: relative;
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      cursor: pointer;
    }

    .modal-title {
      color: #25c2a0;
      margin-top: 0;
    }

    .modal-field {
      margin: 20px 0;
    }

    .modal-label {
      color: #fff;
      display: block;
      margin-bottom: 5px;
    }

    .modal-input {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: none;
      background: #222;
      color: #fff;
    }

    .modal-select {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: none;
      background: #222;
      color: #fff;
    }

    .modal-estimate {
      background: #222;
      padding: 15px;
      border-radius: 8px;
      margin: 20px 0;
    }

    .modal-estimate-title {
      color: #25c2a0;
      font-weight: bold;
    }

    .modal-estimate-content {
      color: #fff;
      margin-top: 5px;
    }

    .modal-button {
      width: 100%;
      margin-top: 15px;
    }

    /* === TABLE STYLES === */
    .table-empty {
      text-align: center;
      color: #666;
      padding: 20px;
    }

    .table-italic {
      font-style: italic;
    }

    .table-center {
      text-align: center;
    }

    /* === PAGINATION STYLES === */
    .pagination-bold {
      font-weight: bold;
    }

    /* === LEADERBOARD STYLES === */
    .leaderboard-rank {
      font-size: 1.6em;
    }

    .leaderboard-avatar {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      vertical-align: middle;
      margin-right: 8px;
    }

    .leaderboard-avatar-placeholder {
      display: inline-block;
      width: 38px;
      height: 38px;
      background: #222;
      border-radius: 50%;
      margin-right: 8px;
    }

    .leaderboard-twitter-link {
      color: #1da1f2;
      text-decoration: none;
    }

    .leaderboard-unknown {
      color: #aaa;
    }

    .leaderboard-wallet {
      font-size: 12px;
    }

    .leaderboard-wins {
      font-weight: bold;
      color: gold;
    }

    /* === DAO STYLES === */
    .dao-placeholder {
      color: #666;
      font-style: italic;
      text-align: center;
      padding: 20px;
    }

    /* === JAVASCRIPT GENERATED CONTENT STYLES === */
    .js-table-empty {
      text-align: center;
      color: #666;
      padding: 20px;
    }

    .js-table-italic {
      color: #666;
      font-style: italic;
    }

    .js-pagination-bold {
      font-weight: bold;
    }

    .js-estimate-rewards {
      color: #25c2a0;
    }

    .js-estimate-total {
      color: #00ff88;
    }

    .js-estimate-apy {
      color: #aaa;
      font-size: 0.9em;
    }

    .js-button-tiered {
      width: 100%;
      margin-top: 10px;
      font-size: 0.9em;
      background: #ffd93d;
      color: #000;
    }

    .js-button-unstake {
      width: 100%;
      margin-top: 10px;
      font-size: 0.9em;
    }

    .js-status-completed {
      text-align: center;
      margin-top: 8px;
      font-size: 0.8em;
      color: #aaa;
    }

    .js-status-processing {
      text-align: center;
      margin-top: 8px;
      font-size: 0.8em;
      color: #ff6b6b;
    }

    .js-status-locked {
      text-align: center;
      margin-top: 8px;
      font-size: 0.8em;
      color: #aaa;
    }

    .js-position-card {
      background: #222;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 10px;
      border-left: 3px solid;
    }

    .js-position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .js-position-amount {
      font-weight: bold;
    }

    .js-position-details {
      font-size: 0.8em;
      color: #aaa;
    }

    .js-position-status {
      font-size: 0.75em;
    }

    .js-position-right {
      text-align: right;
    }

    .js-position-rewards {
      color: #00ff88;
      font-weight: bold;
    }

    .js-position-unlock {
      font-size: 0.8em;
      color: #aaa;
    }

    .js-no-stakes {
      color: #aaa;
      text-align: center;
      padding: 20px;
    }

    .js-activity-placeholder {
      color: #666;
      font-style: italic;
    }

    .js-leaderboard-rank {
      font-size: 1.6em;
    }

    .js-leaderboard-avatar {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      vertical-align: middle;
      margin-right: 8px;
    }

    .js-leaderboard-placeholder {
      display: inline-block;
      width: 38px;
      height: 38px;
      background: #222;
      border-radius: 50%;
      margin-right: 8px;
    }

    .js-leaderboard-twitter {
      color: #1da1f2;
      text-decoration: none;
    }

    .js-leaderboard-unknown {
      color: #aaa;
    }

    .js-leaderboard-wallet {
      font-size: 12px;
    }

    .js-leaderboard-wins {
      font-weight: bold;
      color: gold;
    }

    /* === REMAINING DUPLICATE SECTION STYLES === */
    .duplicate-example-section {
      background: #191919;
      padding: 15px;
      border-radius: 8px;
    }

    .duplicate-example-title {
      color: #00ff88;
      margin-top: 0;
    }

    .duplicate-example-card {
      background: #222;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 10px;
    }

    .duplicate-example-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      font-size: 0.9em;
    }

    .duplicate-journey-content {
      font-size: 0.9em;
      color: #ccc;
      line-height: 1.6;
    }

    .duplicate-journey-step {
      margin-bottom: 6px;
    }

    .duplicate-restrictions {
      background: #ff6b6b20;
      padding: 10px;
      border-radius: 6px;
      margin-top: 15px;
    }

    .duplicate-restrictions-title {
      color: #ff6b6b;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .duplicate-restrictions-text {
      font-size: 0.85em;
      color: #ccc;
    }

    /* === MEDIUM CARD STYLES === */
    .medium-card {
      max-width: 700px;
      margin: 0 auto;
      padding: 25px;
    }

    .medium-card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 25px;
      margin-bottom: 30px;
    }

    .medium-card-single {
      max-width: 700px;
      margin: 0 auto 30px auto;
      padding: 25px;
    }

    /* === RESPONSIVE STYLES === */
    @media (max-width: 768px) {
      .battle-controls {
        margin: 0 10px;
      }

      .medium-card-grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .medium-card,
      .medium-card-single,
      .staking-zone {
        max-width: 100%;
        margin: 0 auto 20px auto;
        padding: 20px;
      }

      .staking-summary-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
    }

    #waldoNotification {
      display: flex;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 99999;
      min-width: 270px;
      max-width: 92vw;
      background: #111;
      color: #fff;
      border-radius: 10px;
      box-shadow: 0 0 18px #25c2a0aa;
      padding: 18px 32px;
      font-size: 1.17rem;
      font-weight: 600;
      opacity: 0.98;
      transition: opacity 0.4s;
    }

    #waldoNotification .dismiss-btn {
      margin-left: 24px;
      background: transparent;
      border: 1.5px solid #25c2a0;
      color: #25c2a0;
      font-size: 1rem;
      font-weight: bold;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.18s, color 0.18s;
    }

    #waldoNotification .dismiss-btn:hover {
      background: #25c2a0;
      color: #111;
    }

    .nft-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.92);
      z-index: 10001;
      align-items: center;
      justify-content: center;
    }

    .nft-modal[style*="display: block"] {
      display: flex !important;
    }

    .close-nft-modal {
      position: absolute;
      top: 24px;
      right: 36px;
      color: #fff;
      font-size: 3rem;
      cursor: pointer;
      font-weight: bold;
      z-index: 10002;
    }

    .nft-modal-image {
      max-width: 96vw;
      max-height: 80vh;
      border-radius: 18px;
      box-shadow: 0 0 40px #25c2a0;
    }

    /* NFT Collection Grid Styles */
    .nft-collection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
      min-height: 120px;
    }

    .nft-collection-item {
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      border-radius: 12px;
      border: 1px solid #333;
      overflow: hidden;
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
    }

    .nft-collection-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(37, 194, 160, 0.3);
      border-color: #25c2a0;
    }

    .nft-collection-image {
      width: 100%;
      height: 120px;
      object-fit: cover;
      background: #222;
    }

    .nft-collection-info {
      padding: 12px;
    }

    .nft-collection-title {
      font-size: 0.9rem;
      font-weight: bold;
      color: #eee;
      margin-bottom: 8px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-height: 1.3;
    }

    .nft-collection-stats {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #ccc;
      margin-bottom: 8px;
    }

    .nft-collection-rarity {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .rarity-common {
      background: #9E9E9E;
      color: white;
    }

    .rarity-uncommon {
      background: #4CAF50;
      color: white;
    }

    .rarity-rare {
      background: #2196F3;
      color: white;
    }

    .rarity-epic {
      background: #9C27B0;
      color: white;
    }

    .rarity-legendary {
      background: #FFD700;
      color: black;
    }

    .nft-collection-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }

    .marketplace-btn {
      background: linear-gradient(45deg, #25c2a0, #00ff88) !important;
      color: white !important;
      border: none !important;
    }

    .manage-btn {
      background: linear-gradient(45deg, #ff5252, #ff8a80) !important;
      color: white !important;
      border: none !important;
    }

    .nft-empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #ccc;
      grid-column: 1 / -1;
    }

    .nft-empty-state h3 {
      font-size: 1.2rem;
      margin-bottom: 10px;
      color: #25c2a0;
    }

    .loading-spinner {
      text-align: center;
      padding: 40px 20px;
      color: #ccc;
      grid-column: 1 / -1;
    }

    .loading-spinner::after {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #ccc;
      border-radius: 50%;
      border-top-color: #25c2a0;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @media (max-width: 768px) {
      .nft-collection-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 15px;
      }

      .nft-collection-actions {
        flex-direction: column;
      }
    }

    .battle-leaderboard-table {
      width: 100%;
      text-align: left;
    }
  </style>
</head>

<body>
  <!-- Navigation Header -->
  <div class="nav-header"
    style="background: #000; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #25c2a0; position: fixed; top: 0; left: 0; right: 0; width: 100%; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.5); backdrop-filter: blur(10px);">
    <div class="nav-logo" style="color: #25c2a0; font-size: 1.5rem; font-weight: bold;">ðŸ’° WALDOCOIN Dashboard</div>
    <div class="nav-links" style="display: flex; align-items: center; gap: 20px;">
      <a href="https://dao-portal.waldocoin.live" class="nav-link"
        style="color: #25c2a0; text-decoration: none; padding: 8px 16px; border-radius: 20px; background: #333; transition: all 0.3s ease;">ðŸ—³ï¸
        DAO</a>
      <a href="https://battle-arena.waldocoin.live" class="nav-link"
        style="color: #25c2a0; text-decoration: none; padding: 8px 16px; border-radius: 20px; background: #333; transition: all 0.3s ease;">âš”ï¸
        Battle Arena</a>
      <a href="https://staking.waldocoin.live" class="nav-link"
        style="color: #25c2a0; text-decoration: none; padding: 8px 16px; border-radius: 20px; background: #333; transition: all 0.3s ease;">ðŸ’°
        Staking</a>
      <a href="https://nft-marketplace.waldocoin.live" class="nav-link"
        style="color: #25c2a0; text-decoration: none; padding: 8px 16px; border-radius: 20px; background: #333; transition: all 0.3s ease;">ðŸª
        NFT Market</a>
      <div class="wallet-display" id="navWalletDisplay"
        style="background: #333; padding: 8px 16px; border-radius: 20px; font-family: monospace; font-size: 0.9rem; color: #25c2a0;">
        Not Connected</div>
      <button class="disconnect-button" onclick="disconnectWallet()" id="navDisconnectBtn"
        style="display: none; background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; cursor: pointer; transition: all 0.3s ease;">ðŸ”Œ
        Disconnect</button>
    </div>
  </div>

  <!-- Wallet Connection Screen -->
  <div id="walletConnectionScreen" class="wallet-connection-screen">
    <div class="dashboard-title-card">
      <h1 class="dashboard-title">WALDOcoin Dashboard</h1>
      <p class="dashboard-subtitle">Connect your wallet to access your stats, battles, and rewards.</p>
      <button id="connectWalletBtn" class="button-style" style="margin-top: 20px;">
        Connect XUMM Wallet
      </button>
    </div>
  </div>

  <div id="waldoLoader" class="waldo-loader" style="display: none;">
    <span class="waldo-loader-text">Loading WALDO Dashboard...</span>
  </div>

  <!-- Main Dashboard Content -->
  <div id="mainContent" style="display: none; padding-top: 80px;">

    <!-- WALDO Dashboard Title -->
    <div>
      <div class="dashboard-title-card">
        <h1 class="dashboard-title">WALDOcoin Dashboard</h1>
        <p class="dashboard-subtitle">Track your memes, earn rewards, and battle for the leaderboard.</p>

        <!-- Navigation Buttons -->
        <div style="display: flex; justify-content: center; gap: 15px; margin-top: 20px; flex-wrap: wrap;">
          <a href="https://dao-portal.waldocoin.live" class="button-style"
            style="text-decoration: none; padding: 10px 20px; font-size: 0.9em;">ðŸ—³ï¸ DAO Portal</a>
          <a href="https://battle-arena.waldocoin.live" class="button-style"
            style="text-decoration: none; padding: 10px 20px; font-size: 0.9em;">âš”ï¸ Battle Arena</a>
          <a href="https://staking.waldocoin.live" class="button-style"
            style="text-decoration: none; padding: 10px 20px; font-size: 0.9em;">ðŸ’° Staking Portal</a>
          <a href="https://nft-marketplace.waldocoin.live" class="button-style"
            style="text-decoration: none; padding: 10px 20px; font-size: 0.9em;">ðŸª NFT Marketplace</a>
        </div>
      </div>
      <!-- Instructions Card -->
    </div>
    <div class="instruction-card">
      <h2>ðŸš€ How to Earn WALDO</h2>
      <ul>
        <li>ðŸ–¼ Post a meme on Twitter with the hashtag <strong>#WaldoMeme</strong></li>
        <li>ðŸ”— Link your Twitter handle to your WALDO wallet below</li>
        <li>ðŸ“Š Watch your meme earn XP and rewards</li>
        <li>ðŸ† Claim or stake your rewards on the dashboard</li>
        <li>ðŸ”¥ Mint your meme as an NFT when it hits 60 XP</li>
      </ul>
    </div>
    <!-- Notification bar -->
    <div id="waldoNotification">
      <span id="waldoMessage">ðŸ‘‹ Welcome back! Ready to earn some WALDO?</span>
      <button type="button" onclick="dismissWaldoNotification()" class="dismiss-btn">Dismiss</button>
    </div>
    <div class="container">
      <!-- WELCOME CARD + LINK TWITTER ACCOUNT -->
      <div class="card big-card">
        <div id="walletControls">
          <button type="button" onclick="logoutWallet()" class="disconnect-btn" id="disconnectBtn"
            style="display:none;">Disconnect</button>
          <button type="button" onclick="connectWallet()" class="connect-btn" id="connectBtn">Connect Wallet</button>
        </div>
        <p id="walletAddress" class="wallet-address">Wallet: Not Connected</p>
        <h3 class="center-text">ðŸ”— Link Twitter Account</h3>
        <div class="twitter-link-container">
          <input type="text" id="twitterHandleInput" placeholder="Enter Twitter handle" class="input-style">
          <button id="linkButton" type="button" onclick="linkTwitterAccount()" class="button-style">Link
            Twitter</button>
        </div>
        <h2>ðŸŽ® Member Level</h2>
        <p id="userLevelTitle" class="center-text level-title-centered">Loading...</p>

        <div class="level-progress-container">
          <progress id="levelProgress" max="100" value="0"></progress>
          <div class="level-progress-indicator" id="levelProgressIndicator">
            <img id="userLevelIcon" alt="Level Icon"
              src="https://waldocoin.live/wp-content/uploads/2025/04/1737843965114.jpg" class="level-icon-moving">
            <div id="xpToNextLevel" class="xp-next-level-moving">...</div>
          </div>
        </div>
      </div>


      <!-- Eligibility Badge Card (top status) -->
      <div class="card" id="eligibilityCard">
        <h2 id="eligibilityTitle">âœ… WALDO Eligibility</h2>
        <div class="content-center">
          <div class="large-number" id="eligibilityStatus">Checkingâ€¦</div>
          <div class="subtitle-text" id="eligibilityDetail">â€”</div>
          <!-- Big thumbs up/down icon -->
          <div class="eligibility-icon" id="eligibilityIcon"
            style="font-size: 4em; margin: 20px 0; opacity: 0; transition: all 0.5s ease;">
            ðŸ‘
          </div>
        </div>
      </div>

      <!-- XP Trends -->
      <div class="card" onclick="openXPChartModal()" style="cursor: pointer;">
        <h2>ðŸ“Š Meme XP Trends <span style="font-size: 0.7em; opacity: 0.7;">ðŸ” Click to expand</span></h2>
        <canvas width="800" height="300" id="xpChart"
          style="width: 100%; height: 300px; background: rgba(255,255,255,0.05); border-radius: 8px;"></canvas>
        <div id="xpChartStatus" style="text-align: center; color: #666; font-size: 12px; margin-top: 10px;">
          Loading chart...
        </div>

      </div>
      <!-- Social Stats -->
      <div class="card">
        <h2>ðŸ“± Social Stats</h2>
        <p><strong>ðŸ”¥ Top Meme:</strong> <span id="socialHandle">Loading...</span></p>
        <p><strong>ðŸ‘¥ Followers:</strong> <span id="socialFollowers">â€”</span></p>
        <p><strong>ðŸ”¥ Total Likes:</strong> <span id="totalLikes">Loading...</span></p>
        <p><strong>ðŸ† Top Meme Likes:</strong> <span id="topMemeLikes">Loading...</span></p>
        <p><strong>ðŸ–¼ï¸ Top Meme Preview:</strong></p>
        <img id="topMemeImage" src="https://waldocoin.live/wp-content/uploads/2025/04/1737843965114.jpg" alt="Top Meme"
          class="meme-thumb">
        <p><a id="topMemeLink" href="#" target="_blank" class="xrpl-link-green">ðŸ”— View Meme</a></p>
      </div>

      <!-- WALDO Value & Trend -->
      <div class="card">
        <h2>ðŸ’¸ WALDO Market Data</h2>
        <div class="waldo-merged-container">

          <!-- Current Value Section -->
          <div class="waldo-section">
            <div class="waldo-section-header">
              <h3 class="waldo-section-title">ðŸ’° Current Value</h3>
              <div class="waldo-section-divider"></div>
            </div>
            <div class="waldo-section-content">
              <div class="waldo-value-details">
                <div class="value-detail-item">
                  <span class="value-label">XRP Rate:</span>
                  <span class="value-amount" id="waldoXrpRate">Loading...</span>
                </div>
                <div class="value-detail-item">
                  <span class="value-label">USD Rate:</span>
                  <span class="value-amount" id="waldoUsdRate">Loading...</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Trend Chart Section -->
          <div class="waldo-section">
            <div class="waldo-section-header">
              <h3 class="waldo-section-title">ðŸ“ˆ 7-Day Price Trend</h3>
              <div class="waldo-section-divider"></div>
            </div>
            <div class="waldo-section-content">
              <div class="chart-container-enhanced">
                <canvas height="140" id="waldoPriceChartMerged" class="chart-canvas"></canvas>
              </div>
              <div class="trend-stats">
                <div class="trend-stat-item">
                  <span class="trend-label">24h Change:</span>
                  <span class="trend-value trend-positive" id="change24h">+0.00%</span>
                </div>
                <div class="trend-stat-item">
                  <span class="trend-label">7d Change:</span>
                  <span class="trend-value trend-positive" id="change7d">+0.00%</span>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- Meme XP Score -->
      <div class="card" id="memeScoreCard">
        <h2>ðŸŽ¯ Your Meme XP Score</h2>
        <div class="meme-score-container">
          <p id="memeScoreDisplay" class="meme-score-enhanced">0</p>
        </div>
        <div class="content-center">
          <div class="level-info" id="currentLevel">Level 1: Waldo Watcher</div>
          <div class="next-level-info" id="nextLevelInfo">250 XP to Level 2</div>
        </div>
      </div>

      <!-- Next Level Requirements Card -->
      <div class="card" id="nextLevelRequirementsCard">
        <h2>ðŸ“ˆ Next Level Requirements</h2>
        <div id="reqStatusSummary" style="color:#ccc;margin-bottom:16px;font-size:18px;">Loading...</div>
        <ul style="list-style:none;padding-left:0;margin:0;display:flex;flex-direction:column;gap:16px;font-size:18px;">
          <li>
            <strong>XP Needed:</strong>
            <span id="reqXpNeeded">â€”</span>
          </li>
          <li>
            <strong>Memes Minted:</strong>
            <span id="reqMintedProgress">â€”</span>
          </li>
          <li>
            <strong>Battles Won:</strong>
            <span id="reqBattlesProgress">â€”</span>
          </li>
          <li>
            <strong>Referrals:</strong>
            <span id="reqReferralsProgress">â€”</span>
          </li>
        </ul>
        <div style="font-size:16px;color:#888;margin-top:20px;line-height:1.6;padding:12px 0;">
          <strong>Note:</strong> For the next level, you need XP threshold plus either Battles Won or Referrals
          (whichever you meet), and
          minimum Memes Minted.
        </div>
      </div>


      <!-- WALDO/USD Trend -->
      <div class="card" onclick="openChartModal()" style="cursor: pointer;">
        <h2>ðŸ“ˆ WALDO/USD Trend (7 Days) <span style="font-size: 0.7em; opacity: 0.7;">ðŸ” Click to expand</span></h2>
        <div class="chart-container">
          <canvas height="160" id="waldoPriceChartNew" class="chart-canvas"></canvas>
        </div>
      </div>

      <!-- XP Gain Breakdown -->
      <div class="card">
        <h2>ðŸ§  XP Gain Breakdown</h2>
        <div class="xp-breakdown-container">
          <div class="xp-breakdown-row">
            <span class="xp-breakdown-label">â¤ï¸ Likes</span>
            <span class="xp-breakdown-value" id="likesXP">0 XP</span>
          </div>
          <div class="xp-breakdown-row">
            <span class="xp-breakdown-label">ðŸ” Retweets</span>
            <span class="xp-breakdown-value" id="retweetsXP">0 XP</span>
          </div>
          <div class="xp-breakdown-row">
            <span class="xp-breakdown-label">âš”ï¸ Battle Wins</span>
            <span class="xp-breakdown-value" id="battleWinsXP">0 XP</span>
          </div>
          <div class="xp-breakdown-row">
            <span class="xp-breakdown-label">ðŸ“£ Referrals</span>
            <span class="xp-breakdown-value" id="referralsXP">0 XP</span>
          </div>
          <div class="xp-breakdown-row">
            <span class="xp-breakdown-label">ðŸ—³ Meme Voting</span>
            <span class="xp-breakdown-value" id="votingXP">0 XP</span>
          </div>
          <div class="xp-breakdown-row">
            <span class="xp-breakdown-label">â³ Staking Bonus</span>
            <span class="xp-breakdown-value-yellow" id="stakingBonusXP">0%</span>
          </div>
        </div>
      </div>

      <!-- Perâ€‘Meme Matured Redemptions -->
      <div class="card" id="perMemeRedemptionsCard">
        <h2>ðŸŽ¯ Perâ€‘Meme Matured Redemptions</h2>
        <p style="font-size:18px;margin:12px 0;"><strong>Count:</strong> <span id="pmRedCount">â€”</span></p>
        <p style="font-size:18px;margin:12px 0;"><strong>Total Paid:</strong> <span id="pmRedTotal">â€”</span></p>
        <div id="pmRedList" style="font-size:16px;margin-top:16px;"></div>
      </div>
    </div> <!-- End container -->

    <!-- Three Cards Above Staking Zone -->
    <div class="container">

      <!-- Referral Program -->
      <div class="card">
        <h2>ðŸ¤ Referral Program</h2>
        <div class="content-center-padded">
          <div class="large-number large-number-yellow" id="refCountMain">0</div>
          <div class="subtitle-text">Friends Referred</div>
          <button type="button" onclick="copyReferral()" class="button-style">Copy Referral Link</button>
          <input id="referralLinkMain" readonly type="text" class="hidden-input">
          <p id="copyStatusMain" class="twitter-link-status"></p>
        </div>
        <div class="referral-benefits">
          <h3 style="color: #25c2a0; margin: 0 0 12px 0; font-size: 16px; text-align: center;">ðŸŽ Referral Rewards</h3>
          <div class="benefit-item">
            <span class="benefit-icon">ðŸ’°</span>
            <span class="benefit-text">10000 WALDO per referral used</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">âš¡</span>
            <span class="benefit-text">XP multiplier bonus</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">ðŸ†</span>
            <span class="benefit-text">Leaderboard ranking boost</span>
          </div>
        </div>
      </div>

      <!-- Recent Activity -->
      <div class="card" onclick="openActivityModal()" style="cursor: pointer;">
        <h2>ðŸ“° Recent Activity <span style="font-size: 0.7em; opacity: 0.7;">ðŸ” Click to expand</span></h2>
        <ul id="activityFeedMain" class="activity-feed activity-feed-padded">
          <li class="activity-item" style="text-align: center; padding: 20px; color: #888;">
            <span class="activity-icon">ðŸ“Š</span>
            <span class="activity-text">No recent activity. Connect your wallet and start using WALDOCOIN!</span>
            <span class="activity-time"></span>
          </li>
        </ul>
        <div class="activity-footer">
          <div style="text-align: center; color: #888; font-size: 12px;">Click anywhere to view all activity</div>
        </div>
      </div>

      <!-- Tokens Burned -->
      <div class="card">
        <h2>ðŸ”¥ Tokens Burned</h2>
        <div class="content-center-padded">
          <div class="large-number large-number-red" id="totalBurnedDisplay">0</div>
          <div class="subtitle-text">WALDO Burned Forever</div>
        </div>
        <div style="margin-top: 20px;">
          <h3 style="font-size: 14px; margin-bottom: 10px;">Recent Burns:</h3>
          <ul id="recentBurnsList" class="activity-feed activity-feed-padded">
            <li class="activity-item">
              <span class="activity-icon">ðŸ”¥</span>
              <span class="activity-text">Loading burn history...</span>
            </li>
          </ul>
        </div>
      </div>



    </div> <!-- End container -->

    <!-- Short term Bonus Option Collapsible Container -->
    <div class="collapsible-container">
      <h2 class="collapsible-header" onclick="toggleShortTermOption()">
        ðŸ’Ž Short Term Bonus Option
        <span id="shortTermToggleIcon" class="toggle-icon collapsed">â–º</span>
      </h2>

      <div id="shortTermSection" class="collapsible-content">

        <!-- Simple Instructions Card -->
        <div class="card">
          <h4 class="duplicate-example-title">ðŸ’° How Meme Rewards Work</h4>

          <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; margin: 15px 0;">
            <h3 style="color: #25c2a0; margin: 0 0 15px 0;">ðŸŽ¯ When You Claim a Meme Reward:</h3>
            <div style="font-size: 16px; line-height: 1.6;">
              <div style="margin: 10px 0; padding: 10px; background: #2a2a2a; border-radius: 6px;">
                <strong style="color: #ff6b6b;">âŒ Get It Now:</strong> Receive tokens immediately (10% fee)
              </div>
              <div style="margin: 10px 0; padding: 10px; background: #2a2a2a; border-radius: 6px;">
                <strong style="color: #51cf66;">âœ… Wait 30 Days:</strong> Get 15% bonus + lower fees (5% fee)
              </div>
            </div>
          </div>

          <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; margin: 15px 0;">
            <h3 style="color: #25c2a0; margin: 0 0 15px 0;">ðŸ“Š Example with 5 WALDO Meme:</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 15px;">
              <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center;">
                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 8px;">Get It Now</div>
                <div style="color: #fff; font-size: 18px; font-weight: bold;">4.5 WALDO</div>
                <div style="color: #888; font-size: 12px;">Right away</div>
              </div>
              <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center;">
                <div style="color: #51cf66; font-weight: bold; margin-bottom: 8px;">Wait 30 Days</div>
                <div style="color: #fff; font-size: 18px; font-weight: bold;">5.46 WALDO</div>
                <div style="color: #888; font-size: 12px;">After 30 days</div>
              </div>
            </div>
          </div>

          <div style="background: #1a1a1a; padding: 20px; border-radius: 8px; margin: 15px 0;">
            <h3 style="color: #25c2a0; margin: 0 0 15px 0;">âœ¨ Simple Rules:</h3>
            <div style="font-size: 15px; line-height: 1.8;">
              â€¢ <strong>Choose for each meme</strong> - no account-wide setting<br>
              â€¢ <strong>Keep claiming new memes</strong> while others are in 30-day bonus<br>
              â€¢ <strong>Choosing bonus unlocks</strong> long-term bonus options<br>
              â€¢ <strong>Mix and match</strong> - some instant, some bonus
            </div>
          </div>
        </div>

        <!-- Level-Specific Reward Tiers Card -->
        <div class="card reward-logic-table">
          <h2 id="rewardTableTitle">ðŸ’Ž Level 1 - WALDO Reward Table (Waldo Watcher)</h2>
          <div class="overflow-auto">
            <table>
              <thead>
                <tr>
                  <th scope="col">Tier</th>
                  <th scope="col">Likes Required</th>
                  <th scope="col">Retweets Required</th>
                  <th scope="col">Base Reward</th>
                  <th scope="col">Get Now</th>
                  <th scope="col">Wait 30 Days</th>
                  <th scope="col">Max Now (40x)</th>
                  <th scope="col">Max Wait (40x)</th>
                </tr>
              </thead>
              <tbody id="rewardTierBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Meme Table with Pagination, XP, Claim/Stake/Mint -->
        <div class="card big-card">
          <div class="centered-flex-container">
            <h2 class="margin-top-0">ðŸ“¸ My Memes</h2>
            <div class="tooltip-wrapper">
              <span class="tooltip-icon">i</span>
              <span class="tooltip-text">Each meme must reach 60 XP to be eligible for minting as an NFT.</span>
            </div>
          </div>
          <div class="overflow-auto">
            <table>
              <thead>
                <tr>
                  <th scope="col">Thumbnail</th>
                  <th scope="col">Tweet Link</th>
                  <th scope="col">Retweets</th>
                  <th scope="col">Likes</th>
                  <th scope="col">XP</th>
                  <th scope="col">Tier</th>
                  <th scope="col">Get Now</th>
                  <th scope="col">Wait 30 Days</th>
                  <th scope="col">Mint</th>
                </tr>
              </thead>
              <tbody id="memeTableBody"></tbody>
            </table>
            <div class="pagination" id="pagination"></div>
          </div>
        </div>

      </div>
    </div>

    <!-- XP Multipliers & Bonuses -->
    <div class="card">
      <h2>âš¡ Active XP Multipliers</h2>
      <div class="xp-multipliers-grid">
        <div class="xp-multiplier-card" id="stakingMultiplierCard">
          <div class="xp-multiplier-value xp-multiplier-value-green" id="stakingMultiplier">ðŸ”„</div>
          <div class="xp-multiplier-label">Locking Bonus Program</div>
          <div class="xp-multiplier-description" id="stakingMultiplierDesc">Loading bonus data...</div>
          <div class="xp-multiplier-status" id="stakingMultiplierStatus"></div>
        </div>
        <div class="xp-multiplier-card" id="battleMultiplierCard">
          <div class="xp-multiplier-value xp-multiplier-value-red" id="battleMultiplier">ðŸ”„</div>
          <div class="xp-multiplier-label">Battle Streak</div>
          <div class="xp-multiplier-description" id="battleMultiplierDesc">Loading battle data...</div>
          <div class="xp-multiplier-status" id="battleMultiplierStatus"></div>
        </div>
        <div class="xp-multiplier-card" id="levelMultiplierCard">
          <div class="xp-multiplier-value xp-multiplier-value-yellow" id="levelMultiplier">ðŸ”„</div>
          <div class="xp-multiplier-label">Level Bonus</div>
          <div class="xp-multiplier-description" id="levelMultiplierDesc">Loading level data...</div>
          <div class="xp-multiplier-status" id="levelMultiplierStatus"></div>
        </div>
        <div class="xp-multiplier-card" id="referralMultiplierCard">
          <div class="xp-multiplier-value xp-multiplier-value-light-green" id="referralMultiplier">ðŸ”„</div>
          <div class="xp-multiplier-label">Referral Bonus</div>
          <div class="xp-multiplier-description" id="referralMultiplierDesc">Loading referral data...</div>
          <div class="xp-multiplier-status" id="referralMultiplierStatus"></div>
        </div>
      </div>
      <div class="xp-tips-box">
        <div class="xp-tips-title">ðŸ’¡ How to Maximize Your XP Multipliers</div>
        <div
          style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0; text-align: left;">
          <div style="background: #1a2f1a; padding: 12px; border-radius: 6px; border-left: 3px solid #25c2a0;">
            <div style="color: #25c2a0; font-weight: bold; margin-bottom: 5px;">ðŸŸ¢ Locking Bonus Program</div>
            <div style="font-size: 12px; line-height: 1.4;">
              <strong>+0.1% XP per 1,000 WALDO staked</strong><br>
              Stake tokens for 30+ days. Max 10% bonus.
            </div>
          </div>
          <div style="background: #2f1a1a; padding: 12px; border-radius: 6px; border-left: 3px solid #ff6b6b;">
            <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">ðŸ”´ Battle Streak</div>
            <div style="font-size: 12px; line-height: 1.4;">
              <strong>+2% XP per battle win</strong><br>
              Win meme battles. Max 20% bonus (10 wins).
            </div>
          </div>
          <div style="background: #2f2f1a; padding: 12px; border-radius: 6px; border-left: 3px solid #ffd93d;">
            <div style="color: #ffd93d; font-weight: bold; margin-bottom: 5px;">ðŸŸ¡ Level Bonus</div>
            <div style="font-size: 12px; line-height: 1.4;">
              <strong>+5% XP per level</strong><br>
              Level up automatically. Max 20% at Level 5.
            </div>
          </div>
          <div style="background: #1a2f1f; padding: 12px; border-radius: 6px; border-left: 3px solid #51cf66;">
            <div style="color: #51cf66; font-weight: bold; margin-bottom: 5px;">ðŸŸ¢ Referral Bonus</div>
            <div style="font-size: 12px; line-height: 1.4;">
              <strong>+1% XP per referral</strong><br>
              Share your link. Max 15% bonus (15 referrals).
            </div>
          </div>
        </div>
        <div
          style="background: #222; padding: 10px; border-radius: 6px; margin-top: 10px; text-align: center; font-size: 12px;">
          <strong style="color: #25c2a0;">ðŸŽ¯ Pro Tip:</strong>
          <span style="color: #ccc;">All multipliers stack! Max possible: 1.1x + 1.2x + 1.2x + 1.15x = ~1.7x total XP
            multiplier (balanced for fair gameplay)!</span>
        </div>
      </div>
    </div>

    <!-- ðŸ”’ COMPREHENSIVE WALDO LONG TERM BONUS ZONE (FULL-WIDTH BAR) -->
    <div class="staking-zone-bar">
      <h2 class="staking-zone-header" onclick="toggleLongTermZone()">
        ðŸ”’ WALDO Long Term Bonus Zone
        <span id="longTermZoneToggleIcon" class="toggle-icon collapsed">â–º</span>
      </h2>

      <div id="longTermZoneSection" class="staking-zone-content">

        <!-- Bonus Summary Stats -->
        <div class="staking-stats">
          <div class="staking-stat-item">
            <div class="staking-stat-value staking-stat-green" id="totalStaked">0 WALDO</div>
            <div class="staking-stat-label">Total in Bonus</div>
          </div>
          <div class="staking-stat-item">
            <div class="staking-stat-value staking-stat-bright-green" id="totalRewards">0 WALDO</div>
            <div class="staking-stat-label">Total Rewards</div>
          </div>
          <div class="staking-stat-item">
            <div class="staking-stat-value staking-stat-green" id="totalStakedDisplay">Loading...</div>
            <div class="staking-stat-label">Ecosystem Total in Bonus</div>
          </div>
        </div>

        <!-- Bonus Rewards Banner -->
        <div class="apy-banner">
          <div class="apy-banner-title">ðŸ“ˆ Long-Term Bonus Rates</div>
          <div class="apy-banner-rates">
            <span class="apy-rate-text">30 days: <strong class="apy-rate-green">+12%</strong></span>
            <span class="apy-rate-text">90 days: <strong class="apy-rate-green">+18%</strong></span>
            <span class="apy-rate-text">180 days: <strong class="apy-rate-bright-green">+25%</strong></span>
            <span class="apy-rate-text">365 days: <strong class="apy-rate-bright-green">+45%</strong></span>
          </div>
          <div class="apy-warning">
            ðŸ’Ž Level 5 gets +2% extra â€¢ âš ï¸ Early unlock: 15% penalty
          </div>
        </div>

        <!-- Long-Term Bonus Table -->
        <div class="staking-table-container">
          <div class="staking-table-wrapper">
            <h3>ðŸ“ˆ Long-Term Bonus Positions</h3>
            <table id="longTermBonusTable" class="styled-table">
              <thead>
                <tr>
                  <th scope="col">Position ID</th>
                  <th scope="col">Amount</th>
                  <th scope="col">Duration</th>
                  <th scope="col">Bonus %</th>
                  <th scope="col">Current Rewards</th>
                  <th scope="col">Status</th>
                  <th scope="col">Action</th>
                </tr>
              </thead>
              <tbody id="stakingPositionsTable">
                <tr>
                  <td colspan="7" class="staking-positions-empty">No active bonus positions</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- Next Payout Timer -->
        <div class="staking-summary-grid">
          <div class="staking-summary-card">
            <h3>â³ Next Bonus Payout</h3>
            <p class="center-text" id="nextPayoutTimer">Calculating...</p>
          </div>
        </div>

        <!-- New Bonus Button -->
        <div class="staking-button-container">
          <button type="button" onclick="showStakingModal()" class="button-style">ðŸ¦ New Bonus Position</button>
        </div>
      </div>
    </div>



    <!-- My NFT Collection -->
    <div class="card big-card">
      <div class="centered-flex-container">
        <h2 class="margin-top-0">ðŸ–¼ï¸ My NFT Collection</h2>
        <div class="tooltip-wrapper">
          <span class="tooltip-icon">i</span>
          <span class="tooltip-text">Your minted NFTs. Click to view details or list for sale on the marketplace.</span>
        </div>
      </div>
      <div id="nftCollectionContainer" class="nft-collection-grid">
        <div class="loading-spinner">Loading your NFT collection...</div>
      </div>
      <div class="nft-collection-actions">
        <a href="https://nft-marketplace.waldocoin.live" class="button-style marketplace-btn"
          style="text-decoration: none; display: inline-block;">
          ðŸª Browse Marketplace
        </a>
        <a href="https://nft-gallery.waldocoin.live" class="button-style manage-btn"
          style="text-decoration: none; display: inline-block;">
          ðŸ–¼ï¸ NFT Gallery
        </a>
      </div>
    </div>

    <!-- NFT Modal -->
    <div id="nftModal" class="nft-modal">
      <span onclick="closeNFTModal()" class="close-nft-modal">&times;</span>
      <img id="nftModalImg" src="https://waldocoin.live/wp-content/uploads/2025/04/1737843965114.jpg" alt="NFT Preview"
        class="nft-modal-image">
    </div>

    <!-- Staking Modal -->
    <div id="stakingModal" class="nft-modal modal-container">
      <div class="modal-content">
        <span onclick="closeStakingModal()" class="close-nft-modal modal-close">&times;</span>
        <h3 class="modal-title">ðŸ¦ Stake WALDO Tokens</h3>

        <div class="modal-field">
          <label class="modal-label">Amount to Stake:</label>
          <input type="number" id="stakeAmount" placeholder="1000" min="1" class="modal-input">
        </div>

        <div class="modal-field">
          <label class="modal-label">Staking Duration:</label>
          <select id="stakeDuration" class="modal-select">
            <option value="30">30 days (+12% bonus)</option>
            <option value="90">90 days (+18% bonus)</option>
            <option value="180">180 days (+25% bonus)</option>
            <option value="365">365 days (+45% bonus)</option>
          </select>
          <div class="modal-hint" style="margin-top: 8px; font-size: 12px; color: #888;">
            ðŸ’Ž Level 5 (Waldo Legend) gets +2% bonus on all durations
          </div>
        </div>

        <div class="modal-estimate">
          <div class="modal-estimate-title">Estimated Returns:</div>
          <div id="stakingEstimate" class="modal-estimate-content">Select amount and duration</div>
        </div>

        <button type="button" onclick="createStake()" class="button-style modal-button">ðŸ¦ Create Stake</button>
      </div>
    </div>
    <!-- DAO Navigation Card -->
    <div class="card big-card dao-voting-card" id="daoVotingCard">
      <h2>ðŸ—³ï¸ WALDOcoin DAO Governance</h2>
      <div style="text-align: center; padding: 20px;">
        <p style="color: #ccc; margin-bottom: 20px;">Participate in decentralized governance and community voting</p>
        <a href="/dao" class="button-style"
          style="display: inline-block; text-decoration: none; padding: 15px 30px; font-size: 1.1em;">
          ðŸ—³ï¸ Enter DAO Portal
        </a>
      </div>
    </div> <!-- Close .battle-bottom-row -->
    <!-- END .container -->

    <!-- Chart Expand Modal -->
    <div id="chartModal" class="nft-modal modal-container" style="display: none;">
      <div class="modal-content" style="max-width: 1200px; width: 95%;">
        <span onclick="closeChartModal()" class="close-nft-modal modal-close">&times;</span>
        <h3 class="modal-title">ðŸ“ˆ WALDO/USD Price Trend (7 Days)</h3>
        <div class="chart-container" style="margin-top: 20px;">
          <canvas id="waldoPriceChartExpanded" class="chart-canvas" height="400"></canvas>
        </div>
      </div>
    </div>

    <!-- XP Chart Expand Modal -->
    <div id="xpChartModal" class="nft-modal modal-container" style="display: none;">
      <div class="modal-content" style="max-width: 1200px; width: 95%;">
        <span onclick="closeXPChartModal()" class="close-nft-modal modal-close">&times;</span>
        <h3 class="modal-title">ðŸ“Š Meme XP Trends (7 Days)</h3>
        <div class="chart-container" style="margin-top: 20px;">
          <canvas width="1000" height="500" id="xpChartExpanded"
            style="width: 100%; height: 500px; background: rgba(255,255,255,0.05); border-radius: 8px;"></canvas>
        </div>
      </div>
    </div>

    <!-- Activity Expand Modal -->
    <div id="activityModal" class="nft-modal modal-container" style="display: none;">
      <div class="modal-content" style="max-width: 800px; width: 95%;">
        <span onclick="closeActivityModal()" class="close-nft-modal modal-close">&times;</span>
        <h3 class="modal-title">ðŸ“° Recent Activity (Latest 20)</h3>
        <div style="margin-top: 20px; max-height: 500px; overflow-y: auto;">
          <ul id="activityFeedExpanded" class="activity-feed" style="margin: 0; padding: 0;">
            <li class="activity-item">
              <span class="activity-icon">â³</span>
              <span class="activity-text">Loading activity...</span>
              <span class="activity-time">Now</span>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!--script src="dashboard-fix.js"></-script-->
    <script>
      (function () {
        let isInitializing = false;
        let originalInit = window.initWaldoDashboard;

        if (originalInit) {
          window.initWaldoDashboard = async function () {
            if (isInitializing) return;
            isInitializing = true;
            try {
              await originalInit.call(this);
            } finally {
              isInitializing = false;
            }
          };
        }

        window.addEventListener('beforeunload', () => {
          if (window.dashboardIntervals) {
            window.dashboardIntervals.forEach(clearInterval);
          }
          if (window.battleTimerInterval) {
            clearInterval(window.battleTimerInterval);
          }
        });
      })();

      (function () {
        // Check authentication without forcing redirects - prioritize sessionStorage
        const wallet = sessionStorage.getItem('xummWallet') || localStorage.getItem('xummWallet');
        const desktopFlag = sessionStorage.getItem('waldoLoginDesktop');

        // If wallet exists but no desktop flag, set it to prevent future issues
        if (wallet && !desktopFlag) {
          sessionStorage.setItem('waldoLoginDesktop', 'true');
        }

        // Update UI based on wallet state
        updateWalletUI(wallet);

        // Only show warning if no wallet, don't redirect automatically
        if (!wallet) {
          console.warn('No wallet found in localStorage. User may need to reconnect.');
          // Show a user-friendly message instead of forcing redirect
          showWaldoNotification('âš ï¸ Please connect your wallet to access the dashboard', 0);
        }
      })();

      /** === CONFIG === **/
      const baseURL = "https://waldocoin-backend-api.onrender.com"; // Production API
      const statsPage = "/"; // Dashboard homepage
      const loginPage = "/connect-waldo-wallet/"; // Login page (adjust if different)

      // ðŸš€ PRODUCTION LAUNCH - ALL FEATURES ENABLED!
      const FEATURES = {
        USER_STATS: true,        // âœ… Working
        CONVERSION_RATES: true,  // âœ… Working
        TOP_MEME: true,         // âœ… Working
        MEME_LISTING: true,     // âœ… Working
        BATTLE_STATUS: true,    // âœ… Working
        DAO_PROPOSALS: true,    // âœ… Working

        // âœ… NOW ENABLED - All endpoints implemented!
        MEME_CLAIMING: true,    // âœ… /api/claim implemented
        NFT_MINTING: true,      // âœ… /api/mint working
        STAKING_SYSTEM: true,   // âœ… Staking endpoints implemented
        TWITTER_LINKING: true,  // âœ… /api/linkTwitter implemented
        ACTIVITY_FEED: true,    // âœ… /api/activity implemented
        BATTLE_ACTIONS: true,   // âœ… Battle action endpoints implemented
        BATTLE_HISTORY: true,   // âœ… /api/battle/history implemented
        BATTLE_LEADERBOARD: true, // âœ… /api/battle/leaderboard implemented
        DAO_VOTING: true        // âœ… /api/dao/vote implemented
      };

      /** === UTILS === **/
      function $(id) { return document.getElementById(id); }
      function getWallet() { return sessionStorage.getItem("xummWallet") || null; }

      function setWallet(wallet) {
        sessionStorage.setItem('xummWallet', wallet);
        // Also store in localStorage for cross-tab sync during active session
        localStorage.setItem('xummWallet', wallet);
        // Broadcast wallet change to other tabs/windows
        broadcastWalletChange(wallet);
      }

      // === SHARED AUTHENTICATION ACROSS ECOSYSTEM ===
      function broadcastWalletChange(wallet) {
        // Use localStorage event to sync across tabs
        localStorage.setItem('waldoWalletSync', JSON.stringify({
          wallet: wallet,
          timestamp: Date.now()
        }));

        // Also use BroadcastChannel for same-origin communication
        if (typeof BroadcastChannel !== 'undefined') {
          const channel = new BroadcastChannel('waldocoin-auth');
          channel.postMessage({
            type: 'WALLET_CHANGED',
            wallet: wallet,
            timestamp: Date.now()
          });
        }
      }

      // === CROSS-SUBDOMAIN WALLET SHARING ===
      function setupCrossSubdomainWalletSharing() {
        window.addEventListener('message', (event) => {
          // Only respond to requests from WALDOCOIN subdomains
          if (!event.origin.includes('waldocoin.live')) return;

          console.log('ðŸ“¨ Received cross-subdomain message:', event.data, 'from:', event.origin);

          if (event.data.type === 'WALLET_REQUEST') {
            const wallet = getWallet();
            console.log('ðŸ“¤ Responding with wallet:', wallet, 'to:', event.origin);

            event.source.postMessage({
              type: 'WALLET_RESPONSE',
              wallet: wallet,
              timestamp: Date.now()
            }, event.origin);
          }

          // Handle global disconnect message
          if (event.data.type === 'GLOBAL_DISCONNECT_REDIRECT') {
            console.log('ðŸšª Received global disconnect message - redirecting to homepage');
            localStorage.removeItem('xummWallet');
            localStorage.removeItem('wallet');
            localStorage.removeItem('waldoWalletSync');
            window.location.href = 'https://waldocoin.live';
          }

          // Handle direct force disconnect message
          if (event.data.type === 'FORCE_DISCONNECT') {
            console.log(`ðŸšª Stats Page: Received FORCE_DISCONNECT from ${event.data.source || 'unknown'} - redirecting immediately`);
            localStorage.removeItem('xummWallet');
            localStorage.removeItem('wallet');
            localStorage.removeItem('waldoWalletSync');
            window.location.href = 'https://waldocoin.live';
          }

          // Handle popup force logout message
          if (event.data.type === 'FORCE_LOGOUT_NOW') {
            console.log(`ðŸšª Stats Page: Received FORCE_LOGOUT_NOW from ${event.data.source || 'unknown'} - redirecting immediately`);
            localStorage.removeItem('xummWallet');
            localStorage.removeItem('wallet');
            localStorage.removeItem('waldoWalletSync');
            localStorage.removeItem('waldoForceLogout');
            localStorage.removeItem('waldoLogoutSignal');
            localStorage.removeItem('waldoLogoutTime');
            window.location.href = 'https://waldocoin.live';
          }
        });

        console.log('âœ… Cross-subdomain wallet sharing enabled');
      }

      function listenForWalletChanges() {
        // Listen for localStorage changes (cross-tab sync)
        window.addEventListener('storage', function (e) {
          if (e.key === 'waldoWalletSync' && e.newValue) {
            try {
              const data = JSON.parse(e.newValue);
              const currentWallet = getWallet();
              if (data.wallet !== currentWallet) {
                // Properly handle wallet sync - remove if null, set if valid
                if (data.wallet) {
                  sessionStorage.setItem('xummWallet', data.wallet);
                  localStorage.setItem('xummWallet', data.wallet);
                  showToast('Wallet connected in another tab - refreshing...', 'success');
                  setTimeout(() => location.reload(), 1500);
                } else {
                  // Properly clear wallet storage when disconnected
                  sessionStorage.removeItem('xummWallet');
                  sessionStorage.removeItem('wallet');
                  sessionStorage.removeItem('walletAddress');
                  sessionStorage.removeItem('connectedWallet');

                  localStorage.removeItem('xummWallet');
                  localStorage.removeItem('wallet');
                  localStorage.removeItem('walletAddress');
                  localStorage.removeItem('connectedWallet');
                  localStorage.removeItem('waldoWalletSync');
                  showToast('Wallet disconnected in another tab - refreshing...', 'info');
                  setTimeout(() => location.reload(), 1500);
                }
              }
            } catch (e) {
              console.warn('Failed to parse wallet sync data:', e);
            }
          }

          // === LOGOUT FLAG DETECTION REMOVED ===
          // No longer needed since battle arena doesn't have disconnect
        });

        // Listen for BroadcastChannel messages
        if (typeof BroadcastChannel !== 'undefined') {
          const channel = new BroadcastChannel('waldocoin-auth');
          channel.onmessage = function (event) {
            if (event.data.type === 'WALLET_CHANGED') {
              const currentWallet = getWallet();
              if (event.data.wallet !== currentWallet) {
                // Properly handle wallet sync - remove if null, set if valid
                if (event.data.wallet) {
                  sessionStorage.setItem('xummWallet', event.data.wallet);
                  localStorage.setItem('xummWallet', event.data.wallet);
                  showToast('Wallet connected in another tab - refreshing...', 'success');
                  setTimeout(() => location.reload(), 1500);
                } else {
                  // Properly clear wallet storage when disconnected
                  sessionStorage.removeItem('xummWallet');
                  sessionStorage.removeItem('wallet');
                  sessionStorage.removeItem('walletAddress');
                  sessionStorage.removeItem('connectedWallet');

                  localStorage.removeItem('xummWallet');
                  localStorage.removeItem('wallet');
                  localStorage.removeItem('walletAddress');
                  localStorage.removeItem('connectedWallet');
                  localStorage.removeItem('waldoWalletSync');
                  showToast('Wallet disconnected in another tab - refreshing...', 'info');
                  setTimeout(() => location.reload(), 1500);
                }
              }
            }

            // === BROADCAST LOGOUT DETECTION REMOVED ===
            // No longer needed since battle arena doesn't have disconnect
          };
        }
      }

      /** === LEVELS === **/
      const levelTitles = {
        1: "Waldo Watcher",
        2: "Waldo Scout",
        3: "Waldo Agent",
        4: "Waldo Commander",
        5: "Waldo Legend"
      };
      const levelThresholds = [0, 1000, 3000, 7000, 15000];
      const levelImages = {
        1: "https://waldocoin.live/wp-content/uploads/2025/04/1737843965114.jpg",
        2: "https://waldocoin.live/wp-content/uploads/2025/03/1737843965414.jpeg",
        3: "https://waldocoin.live/wp-content/uploads/2025/03/F.A.F.O.png",
        4: "https://waldocoin.live/wp-content/uploads/2025/04/WhatsApp-Image-2025-04-03-at-22.52.10.jpeg",
        5: "https://waldocoin.live/wp-content/uploads/2025/04/WhatsApp-Image-2025-04-03-at-22.53.38.jpeg"
      };
      const rewardTiers = [
        { tier: 1, likes: 25, retweets: 0, base: 1 },
        { tier: 2, likes: 50, retweets: 5, base: 2 },
        { tier: 3, likes: 100, retweets: 10, base: 5 },
        { tier: 4, likes: 500, retweets: 50, base: 25 },
        { tier: 5, likes: 1000, retweets: 100, base: 50 }
      ];

      /** === NOTIFICATIONS === **/
      function showWaldoNotification(msg, timeout = 5000) {
        const n = $("waldoNotification"), m = $("waldoMessage");
        if (!n || !m) return;
        m.textContent = msg;
        n.style.display = "flex";
        if (timeout) setTimeout(() => { n.style.display = "none"; }, timeout);
      }
      function dismissWaldoNotification() { $("waldoNotification")?.style && ($("waldoNotification").style.display = "none"); }

      /** === TOASTS === **/
      function showToast(message, type = "info", duration = 3500) {
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.textContent = message;
        toast.style.cssText = `
    position: fixed; bottom:30px; left:50%; transform:translateX(-50%);
    background: ${type === "error" ? "#e63e3e" : type === "success" ? "#2ecc71" : "#222"};
    color:white; padding:12px 20px; border-radius:8px; font-weight:600;
    z-index:99999; box-shadow:0 0 12px rgba(0,0,0,0.28);
  `;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
      }

      /** === COPY REFERRAL === **/
      function copyReferral() {
        // Try main referral card first, then fallback to other referral inputs
        const input = $("referralLinkMain") || $("referralLink");
        const status = $("copyStatusMain") || $("copyStatus");

        if (!input) {
          console.warn('No referral input found');
          return;
        }

        if (!input.value) {
          if (status) status.textContent = "âŒ No referral link available";
          return;
        }

        input.select();
        navigator.clipboard.writeText(input.value)
          .then(() => {
            if (status) status.textContent = "ðŸ“‹ Copied!";
            setTimeout(() => {
              if (status) status.textContent = "";
            }, 3000);
          })
          .catch(() => {
            if (status) status.textContent = "âŒ Copy failed.";
          });
      }

      /** === LEVEL-SPECIFIC REWARD TIERS === **/
      const levelRewardTables = {
        1: {
          title: "Level 1 - WALDO Reward Table (Waldo Watcher)",
          tiers: [
            { tier: 1, likes: 25, retweets: 0, base: 1.00, instant: 0.9005, staking: 1.1078, maxNoStake: 40.00, maxStake: 44.3120 },
            { tier: 2, likes: 50, retweets: 5, base: 2.00, instant: 1.8010, staking: 2.2156, maxNoStake: 80.00, maxStake: 88.6240 },
            { tier: 3, likes: 100, retweets: 10, base: 5.00, instant: 4.5025, staking: 5.5390, maxNoStake: 200.00, maxStake: 221.5600 },
            { tier: 4, likes: 500, retweets: 50, base: 25.00, instant: 22.5125, staking: 27.6950, maxNoStake: 1000.00, maxStake: 1107.8000 },
            { tier: 5, likes: 1000, retweets: 100, base: 50.00, instant: 45.0250, staking: 55.3900, maxNoStake: 2000.00, maxStake: 2215.6000 }
          ]
        },
        2: {
          title: "Level 2 - WALDO Reward Table (Waldo Scout)",
          tiers: [
            { tier: 1, likes: 25, retweets: 0, base: 1.00, instant: 0.9010, staking: 1.1232, maxNoStake: 40.00, maxStake: 44.9280 },
            { tier: 2, likes: 50, retweets: 5, base: 2.00, instant: 1.8020, staking: 2.2464, maxNoStake: 80.00, maxStake: 89.8560 },
            { tier: 3, likes: 100, retweets: 10, base: 5.00, instant: 4.5050, staking: 5.6160, maxNoStake: 200.00, maxStake: 224.6400 },
            { tier: 4, likes: 500, retweets: 50, base: 25.00, instant: 22.5250, staking: 28.0800, maxNoStake: 1000.00, maxStake: 1123.2000 },
            { tier: 5, likes: 1000, retweets: 100, base: 50.00, instant: 45.0500, staking: 56.1600, maxNoStake: 2000.00, maxStake: 2246.4000 }
          ]
        },
        3: {
          title: "Level 3 - WALDO Reward Table (Waldo Agent)",
          tiers: [
            { tier: 1, likes: 25, retweets: 0, base: 1.00, instant: 0.9015, staking: 1.1387, maxNoStake: 40.00, maxStake: 45.5480 },
            { tier: 2, likes: 50, retweets: 5, base: 2.00, instant: 1.8030, staking: 2.2774, maxNoStake: 80.00, maxStake: 91.0960 },
            { tier: 3, likes: 100, retweets: 10, base: 5.00, instant: 4.5075, staking: 5.6935, maxNoStake: 200.00, maxStake: 227.7400 },
            { tier: 4, likes: 500, retweets: 50, base: 25.00, instant: 22.5375, staking: 28.4675, maxNoStake: 1000.00, maxStake: 1138.7000 },
            { tier: 5, likes: 1000, retweets: 100, base: 50.00, instant: 45.0750, staking: 56.9350, maxNoStake: 2000.00, maxStake: 2277.4000 }
          ]
        },
        4: {
          title: "Level 4 - WALDO Reward Table (Waldo Commander)",
          tiers: [
            { tier: 1, likes: 25, retweets: 0, base: 1.00, instant: 0.9020, staking: 1.1543, maxNoStake: 40.00, maxStake: 46.1720 },
            { tier: 2, likes: 50, retweets: 5, base: 2.00, instant: 1.8040, staking: 2.3086, maxNoStake: 80.00, maxStake: 92.3440 },
            { tier: 3, likes: 100, retweets: 10, base: 5.00, instant: 4.5100, staking: 5.7715, maxNoStake: 200.00, maxStake: 230.8600 },
            { tier: 4, likes: 500, retweets: 50, base: 25.00, instant: 22.5500, staking: 28.8575, maxNoStake: 1000.00, maxStake: 1154.3000 },
            { tier: 5, likes: 1000, retweets: 100, base: 50.00, instant: 45.1000, staking: 57.7150, maxNoStake: 2000.00, maxStake: 2308.6000 }
          ]
        },
        5: {
          title: "Level 5 - WALDO Reward Table (Waldo Legend)",
          tiers: [
            { tier: 1, likes: 25, retweets: 0, base: 1.00, instant: 0.9025, staking: 1.1700, maxNoStake: 40.00, maxStake: 46.8000 },
            { tier: 2, likes: 50, retweets: 5, base: 2.00, instant: 1.8050, staking: 2.3400, maxNoStake: 80.00, maxStake: 93.6000 },
            { tier: 3, likes: 100, retweets: 10, base: 5.00, instant: 4.5125, staking: 5.8500, maxNoStake: 200.00, maxStake: 234.0000 },
            { tier: 4, likes: 500, retweets: 50, base: 25.00, instant: 22.5625, staking: 29.2500, maxNoStake: 1000.00, maxStake: 1170.0000 },
            { tier: 5, likes: 1000, retweets: 100, base: 50.00, instant: 45.1250, staking: 58.5000, maxNoStake: 2000.00, maxStake: 2340.0000 }
          ]
        }
      };

      function getCurrentUserLevel(xp) {
        const val = Number.isFinite(xp) ? xp : 0;
        if (val >= 10000) return 5; // Waldo Legend
        if (val >= 5000) return 4;  // Waldo Commander
        if (val >= 2000) return 3;  // Waldo Agent
        if (val >= 500) return 2;   // Waldo Scout
        return 1; // Waldo Watcher (default)
      }

      async function generateRewardTable(userLevel = 1) {
        const table = $("rewardTierBody");
        const titleElement = $("rewardTableTitle");

        console.log('ðŸŽ¯ Generating dynamic reward table for level:', userLevel);
        console.log('ðŸ“Š Table element found:', !!table);

        if (!table) {
          console.warn('âŒ Reward table body element not found');
          return;
        }

        // Get level data for structure (likes/retweets requirements)
        const levelData = levelRewardTables[userLevel] || levelRewardTables[1];

        // Update title
        if (titleElement) {
          titleElement.textContent = `ðŸ’Ž ${levelData.title}`;
        }

        // Clear table and show loading
        table.innerHTML = `
          <tr>
            <td colspan="8" style="text-align: center; padding: 20px; color: #888;">
              ðŸ”„ Loading dynamic rewards with active bonuses...
            </td>
          </tr>
        `;

        try {
          // Fetch dynamic rewards for each tier using backend API
          const tierPromises = levelData.tiers.map(async (tier) => {
            try {
              // Get dynamic reward calculation from backend
              const response = await fetch(`${baseURL}/api/rewards/calculate?baseAmount=${tier.base}&rewardType=meme`);
              const rewardData = await response.json();

              if (rewardData.success) {
                // Calculate instant and bonus payouts with dynamic multipliers
                const dynamicBase = rewardData.finalAmount;
                const instantPayout = dynamicBase * 0.9; // 10% fee
                const bonusPayout = dynamicBase * 0.95 * 1.15; // 5% fee + 15% bonus
                const maxInstant = instantPayout * 40;
                const maxBonus = bonusPayout * 40;

                return {
                  ...tier,
                  dynamicBase: dynamicBase,
                  instantPayout: instantPayout,
                  bonusPayout: bonusPayout,
                  maxInstant: maxInstant,
                  maxBonus: maxBonus,
                  hasBonus: rewardData.totalMultiplier > 1,
                  bonusMultiplier: rewardData.totalMultiplier,
                  appliedBonuses: rewardData.appliedBonuses || []
                };
              } else {
                // Fallback to static data if API fails
                return {
                  ...tier,
                  dynamicBase: tier.base,
                  instantPayout: tier.instant,
                  bonusPayout: tier.staking,
                  maxInstant: tier.maxNoStake,
                  maxBonus: tier.maxStake,
                  hasBonus: false,
                  bonusMultiplier: 1,
                  appliedBonuses: []
                };
              }
            } catch (error) {
              console.warn(`Failed to fetch reward for tier ${tier.tier}:`, error);
              // Fallback to static data
              return {
                ...tier,
                dynamicBase: tier.base,
                instantPayout: tier.instant,
                bonusPayout: tier.staking,
                maxInstant: tier.maxNoStake,
                maxBonus: tier.maxStake,
                hasBonus: false,
                bonusMultiplier: 1,
                appliedBonuses: []
              };
            }
          });

          const dynamicTiers = await Promise.all(tierPromises);

          // Clear loading and populate with dynamic data
          table.innerHTML = "";

          dynamicTiers.forEach(tier => {
            const row = document.createElement("tr");
            const bonusIndicator = tier.hasBonus ? ` ðŸ”¥ ${tier.bonusMultiplier}x` : '';

            row.innerHTML = `
              <td>${tier.tier}</td>
              <td>${tier.likes}+</td>
              <td>${tier.retweets}+</td>
              <td>${tier.dynamicBase.toFixed(2)} WALDO${bonusIndicator}</td>
              <td>${tier.instantPayout.toFixed(4)} WALDO</td>
              <td>${tier.bonusPayout.toFixed(4)} WALDO</td>
              <td>${tier.maxInstant.toFixed(2)} WALDO</td>
              <td>${tier.maxBonus.toFixed(4)} WALDO</td>
            `;

            // Add bonus styling if active
            if (tier.hasBonus) {
              row.style.backgroundColor = '#1a2f1a';
              row.style.border = '1px solid #25c2a0';
            }

            table.appendChild(row);
          });

          // Show bonus info if any bonuses are active
          const hasAnyBonus = dynamicTiers.some(t => t.hasBonus);
          if (hasAnyBonus) {
            const bonusRow = document.createElement("tr");
            bonusRow.innerHTML = `
              <td colspan="8" style="text-align: center; padding: 10px; background: #1a2f1a; color: #25c2a0; font-size: 12px;">
                ðŸ”¥ Active bonus multipliers applied! Rewards are dynamically calculated.
              </td>
            `;
            table.appendChild(bonusRow);
          }

          console.log('âœ… Dynamic reward table generated successfully');

        } catch (error) {
          console.error('âŒ Failed to generate dynamic reward table:', error);

          // Fallback to static table
          table.innerHTML = "";
          levelData.tiers.forEach(t => {
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>${t.tier}</td>
              <td>${t.likes}+</td>
              <td>${t.retweets}+</td>
              <td>${t.base.toFixed(2)} WALDO</td>
              <td>${t.instant.toFixed(4)} WALDO</td>
              <td>${t.staking.toFixed(4)} WALDO</td>
              <td>${t.maxNoStake.toFixed(2)} WALDO</td>
              <td>${t.maxStake.toFixed(4)} WALDO</td>
            `;
            table.appendChild(row);
          });

          // Show fallback notice
          const fallbackRow = document.createElement("tr");
          fallbackRow.innerHTML = `
            <td colspan="8" style="text-align: center; padding: 10px; background: #2a1a1a; color: #888; font-size: 12px;">
              âš ï¸ Using static rewards (API unavailable)
            </td>
          `;
          table.appendChild(fallbackRow);
        }
      }

      /** === COUNT-UP UTILS === */
      function animateCountUp(el, to, duration = 800) {
        try {
          if (!el) return;
          const start = Number(el.textContent.replace(/[^0-9.]/g, '')) || 0;
          const diff = to - start;
          const startTime = performance.now();
          function step(now) {
            const p = Math.min(1, (now - startTime) / duration);
            const val = Math.floor(start + diff * p);
            el.textContent = val.toLocaleString();
            if (p < 1) requestAnimationFrame(step);
          }
          requestAnimationFrame(step);
        } catch (e) { /* noop */ }
      }

      /** === XP CALC === **/
      function calculateXPToNextLevel(xp) {
        for (let i = 0; i < levelThresholds.length; i++)
          if (xp < levelThresholds[i]) return levelThresholds[i] - xp;
        return 0;
      }

      /** === CHARTS === **/
      let xpChartInstance = null;
      let lastXPChartData = null; // Store last chart data to prevent unnecessary redraws

      // Generate mock XP trend data for display
      function generateMockXPTrend(currentXP, currentLevel) {
        const days = ['7 days ago', '6 days ago', '5 days ago', '4 days ago', '3 days ago', '2 days ago', 'Yesterday'];
        const xpValues = [];

        // Generate a realistic progression leading to current XP
        const baseXP = Math.max(0, currentXP - 100); // Start from slightly lower
        for (let i = 0; i < 7; i++) {
          const progress = i / 6; // 0 to 1
          const xp = Math.floor(baseXP + (currentXP - baseXP) * progress);
          xpValues.push(xp);
        }

        return {
          labels: days,
          datasets: [{
            label: 'Meme XP Progress',
            data: xpValues,
            borderColor: '#25c2a0',
            backgroundColor: 'rgba(37, 194, 160, 0.1)',
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#25c2a0',
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2,
            pointRadius: 5
          }]
        };
      }

      // Show placeholder when Chart.js isn't available
      function showXPChartPlaceholder(canvas) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // Set styles
        ctx.fillStyle = '#333';
        ctx.strokeStyle = '#25c2a0';
        ctx.lineWidth = 2;
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';

        // Draw placeholder chart
        ctx.fillText('ðŸ“Š Meme XP Trends', width / 2, 30);
        ctx.font = '12px Arial';
        ctx.fillStyle = '#666';
        ctx.fillText('Chart loading...', width / 2, height / 2);

        // Draw simple line
        ctx.beginPath();
        ctx.moveTo(50, height - 50);
        ctx.lineTo(width - 50, height - 100);
        ctx.stroke();
      }

      // Simple canvas-based chart as alternative to Chart.js
      function drawSimpleXPChart(canvas, data) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // Chart dimensions - adjust padding based on canvas size
        const isLarge = width > 900; // Modal canvas is larger
        const padding = isLarge ? 80 : 60;
        const chartWidth = width - (padding * 2);
        const chartHeight = height - (padding * 2);

        // Get data values
        const values = data.datasets[0].data;
        const labels = data.labels;
        const maxValue = Math.max(...values, 1);

        // Draw background
        ctx.fillStyle = 'rgba(37, 194, 160, 0.1)';
        ctx.fillRect(padding, padding, chartWidth, chartHeight);

        // Draw grid lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const y = padding + (chartHeight / 4) * i;
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(padding + chartWidth, y);
          ctx.stroke();
        }

        // Draw data line
        ctx.strokeStyle = '#25c2a0';
        ctx.lineWidth = 3;
        ctx.beginPath();

        for (let i = 0; i < values.length; i++) {
          const x = padding + (chartWidth / (values.length - 1)) * i;
          const y = padding + chartHeight - (values[i] / maxValue) * chartHeight;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Draw data points
        ctx.fillStyle = '#25c2a0';
        const pointSize = isLarge ? 8 : 6;
        for (let i = 0; i < values.length; i++) {
          const x = padding + (chartWidth / (values.length - 1)) * i;
          const y = padding + chartHeight - (values[i] / maxValue) * chartHeight;

          ctx.beginPath();
          ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
          ctx.fill();

          // Add white border to points
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = isLarge ? 3 : 2;
          ctx.stroke();
        }

        // Draw Y-axis values
        ctx.fillStyle = '#999';
        ctx.font = isLarge ? '16px Arial' : '12px Arial';
        ctx.textAlign = 'right';
        for (let i = 0; i <= 4; i++) {
          const value = Math.round((maxValue / 4) * (4 - i));
          const y = padding + (chartHeight / 4) * i + (isLarge ? 6 : 4);
          ctx.fillText(value.toString(), padding - (isLarge ? 15 : 10), y);
        }

        // Draw labels
        ctx.fillStyle = '#ccc';
        ctx.font = isLarge ? '18px Arial' : '14px Arial';
        ctx.textAlign = 'center';
        for (let i = 0; i < labels.length; i++) {
          const x = padding + (chartWidth / (labels.length - 1)) * i;
          ctx.fillText(labels[i], x, height - (isLarge ? 20 : 15));
        }

        // Draw title
        ctx.fillStyle = '#fff';
        ctx.font = isLarge ? '24px Arial' : '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Meme XP Progress', width / 2, isLarge ? 40 : 30);

        // Store data for modal
        xpChartModalData = data;

        // Update status
        const statusEl = $("xpChartStatus");
        if (statusEl) {
          statusEl.textContent = '';
          statusEl.style.display = 'none';
        }
      }

      let priceChartMergedInstance = null;
      let priceChartNewInstance = null;
      let priceChartExpandedInstance = null;
      let lastChartData = null; // Store chart data for modal
      let xpChartModalData = null; // Store XP chart data for modal

      function renderXPTrendChart(xpTrend) {
        console.log('ðŸŽ¯ renderXPTrendChart called with:', xpTrend);

        // Check if data has changed to prevent unnecessary redraws
        const dataString = JSON.stringify(xpTrend);
        if (lastXPChartData === dataString && xpChartInstance) {
          console.log('ðŸ“Š XP Chart data unchanged, skipping redraw');
          return;
        }
        lastXPChartData = dataString;

        const el = $("xpChart");
        const statusEl = $("xpChartStatus");

        if (!el) {
          console.warn('âŒ XP Chart canvas element not found');
          if (statusEl) statusEl.textContent = 'Chart element not found';
          return;
        }

        // Use simple canvas chart by default (Chart.js has animation issues)
        console.log('âœ… Canvas found, rendering simple chart...');
        if (statusEl) statusEl.textContent = 'Rendering chart...';
        drawSimpleXPChart(el, xpTrend || generateMockXPTrend(0, 1));
        return;

        // Chart.js code disabled due to animation issues
        /*
        if (!window.Chart) {
          console.warn('âŒ Chart.js not loaded, using simple canvas chart');
          if (statusEl) statusEl.textContent = 'Using simple chart';
          drawSimpleXPChart(el, xpTrend || generateMockXPTrend(0, 1));
          return;
        }

        console.log('âœ… Chart.js loaded, canvas found, rendering chart...');
        if (statusEl) statusEl.textContent = 'Rendering chart...';*/

        const ctx = el.getContext("2d");
        if (xpChartInstance) {
          console.log('ðŸ—‘ï¸ Destroying previous chart instance');
          xpChartInstance.destroy();
        }

        // Create default chart data if none provided
        const defaultData = {
          labels: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6', 'Day 7'],
          datasets: [{
            label: 'Meme XP',
            data: [0, 0, 0, 0, 0, 0, 0],
            borderColor: '#25c2a0',
            backgroundColor: 'rgba(37, 194, 160, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4
          }]
        };

        try {
          console.log('ðŸ“Š Creating Chart.js instance with data:', xpTrend || defaultData);

          xpChartInstance = new Chart(ctx, {
            type: "line",
            data: xpTrend || defaultData,
            options: {
              responsive: false,  // Disable responsive to prevent resize loops
              maintainAspectRatio: true,
              animation: false,  // Disable all animations
              animations: false, // Disable animations (alternative property)
              transitions: {
                active: {
                  animation: {
                    duration: 0
                  }
                }
              },
              interaction: {
                intersect: false,
                mode: 'index'
              },
              elements: {
                line: {
                  tension: 0.4
                },
                point: {
                  radius: 4,
                  hoverRadius: 6
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(255, 255, 255, 0.1)'
                  },
                  ticks: {
                    color: '#ccc'
                  }
                },
                x: {
                  grid: {
                    color: 'rgba(255, 255, 255, 0.1)'
                  },
                  ticks: {
                    color: '#ccc'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: '#ccc'
                  }
                }
              }
            }
          });

          // Force stop any animations that might still be running
          if (xpChartInstance.stop) {
            xpChartInstance.stop();
          }

          console.log('âœ… Chart created successfully!');
          const statusEl = $("xpChartStatus");
          if (statusEl) {
            statusEl.textContent = '';
            statusEl.style.display = 'none'; // Hide status once chart is loaded
          }

        } catch (error) {
          console.error('âŒ Error creating chart:', error);
          const statusEl = $("xpChartStatus");
          if (statusEl) statusEl.textContent = 'Error creating chart: ' + error.message;
          showXPChartPlaceholder(el);
        }
      }

      // Initialize price charts with real-time data
      async function initializePriceCharts() {
        // Check if Chart.js is loaded
        if (typeof Chart === 'undefined') {
          console.error('âŒ Chart.js is not loaded!');
          showPlaceholderCharts();
          return;
        }

        try {
          // STEP 1: Get real-time price from DEX (same as exchange widget)
          const marketRes = await fetch(`${baseURL}/api/market/wlo?_=${Date.now()}`, { cache: 'no-store' });
          if (!marketRes.ok) {
            throw new Error(`Market API failed: ${marketRes.status}`);
          }
          const marketData = await marketRes.json();

          // Get current XRP price per WLO from DEX
          const xrpPerWlo = (marketData?.xrpPerWlo && isFinite(marketData.xrpPerWlo))
            ? marketData.xrpPerWlo
            : (marketData?.best?.mid || 0.0001);

          // Approximate USD rate (XRP ~$0.50)
          const xrpUsdRate = 0.50;
          const usdPerWlo = xrpPerWlo * xrpUsdRate;

          // Update rate displays immediately with REAL price
          const xrpEl = $("waldoXrpRate");
          const usdEl = $("waldoUsdRate");

          if (xrpEl) {
            xrpEl.textContent = `${xrpPerWlo.toFixed(8)} XRP`;
          }
          if (usdEl) {
            usdEl.textContent = `$${usdPerWlo.toFixed(8)}`;
          }

          // STEP 2: Get historical data for charts
          const res = await fetch(`${baseURL}/api/market/price-history?days=7`);
          const data = await res.json();

          if (data.success && data.history && data.history.length > 0) {
            const labels = data.history.map(h => {
              const date = new Date(h.timestamp);
              return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            });
            const prices = data.history.map(h => h.usdPrice || 0);

            // Calculate 24h and 7d changes
            const currentPrice = prices[prices.length - 1];
            const price24hAgo = prices.length > 1 ? prices[prices.length - 2] : currentPrice;
            const price7dAgo = prices[0];

            const change24h = ((currentPrice - price24hAgo) / price24hAgo * 100).toFixed(2);
            const change7d = ((currentPrice - price7dAgo) / price7dAgo * 100).toFixed(2);

            // Update change displays
            const change24hEl = $("change24h");
            const change7dEl = $("change7d");

            if (change24hEl) {
              change24hEl.textContent = `${change24h >= 0 ? '+' : ''}${change24h}%`;
              change24hEl.className = `trend-value ${change24h >= 0 ? 'trend-positive' : 'trend-negative'}`;
            }

            if (change7dEl) {
              change7dEl.textContent = `${change7d >= 0 ? '+' : ''}${change7d}%`;
              change7dEl.className = `trend-value ${change7d >= 0 ? 'trend-positive' : 'trend-negative'}`;
            }

            const chartData = {
              labels: labels,
              datasets: [{
                label: 'WALDO/USD',
                data: prices,
                borderColor: '#25c2a0',
                backgroundColor: 'rgba(37, 194, 160, 0.1)',
                borderWidth: 2,
                fill: true,
                tension: 0.4,
                pointRadius: 3,
                pointHoverRadius: 5,
                pointBackgroundColor: '#25c2a0',
                pointBorderColor: '#fff',
                pointBorderWidth: 2
              }]
            };

            // Store chart data for modal
            lastChartData = { data: chartData, labels: labels, prices: prices };

            const chartOptions = {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#25c2a0',
                  bodyColor: '#fff',
                  borderColor: '#25c2a0',
                  borderWidth: 1,
                  padding: 10,
                  displayColors: false,
                  callbacks: {
                    label: function (context) {
                      return `$${context.parsed.y.toFixed(6)}`;
                    }
                  }
                }
              },
              scales: {
                x: {
                  grid: { color: 'rgba(255, 255, 255, 0.1)' },
                  ticks: { color: '#ccc', font: { size: 10 } }
                },
                y: {
                  grid: { color: 'rgba(255, 255, 255, 0.1)' },
                  ticks: {
                    color: '#ccc',
                    font: { size: 10 },
                    callback: function (value) {
                      return '$' + value.toFixed(6);
                    }
                  }
                }
              }
            };

            // Render merged chart
            const mergedEl = $("waldoPriceChartMerged");
            if (mergedEl) {
              const ctx = mergedEl.getContext("2d");
              if (priceChartMergedInstance) {
                priceChartMergedInstance.destroy();
              }
              priceChartMergedInstance = new Chart(ctx, {
                type: "line",
                data: chartData,
                options: chartOptions
              });
            }

            // Render new chart
            const newEl = $("waldoPriceChartNew");
            if (newEl) {
              const ctx = newEl.getContext("2d");
              if (priceChartNewInstance) {
                priceChartNewInstance.destroy();
              }
              priceChartNewInstance = new Chart(ctx, {
                type: "line",
                data: chartData,
                options: chartOptions
              });
            }
          } else {
            showPlaceholderCharts();
          }
        } catch (err) {
          console.error('Error loading price charts:', err);
          showPlaceholderCharts();
        }
      }

      function showPlaceholderCharts() {
        // Show placeholder data when API isn't available
        const labels = ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6', 'Day 7'];
        const prices = [0.000001, 0.000001, 0.000001, 0.000001, 0.000001, 0.000001, 0.000001];

        $("waldoXrpRate") && ($("waldoXrpRate").textContent = 'Loading...');
        $("waldoUsdRate") && ($("waldoUsdRate").textContent = 'Loading...');
        $("change24h") && ($("change24h").textContent = '+0.00%');
        $("change7d") && ($("change7d").textContent = '+0.00%');

        const chartData = {
          labels: labels,
          datasets: [{
            label: 'WALDO/USD',
            data: prices,
            borderColor: '#666',
            backgroundColor: 'rgba(102, 102, 102, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4
          }]
        };

        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: { enabled: false }
          },
          scales: {
            x: {
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              ticks: { color: '#666' }
            },
            y: {
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              ticks: { color: '#666' }
            }
          }
        };

        const mergedEl = $("waldoPriceChartMerged");
        if (mergedEl) {
          const ctx = mergedEl.getContext("2d");
          if (priceChartMergedInstance) priceChartMergedInstance.destroy();
          priceChartMergedInstance = new Chart(ctx, {
            type: "line",
            data: chartData,
            options: chartOptions
          });
        }

        const newEl = $("waldoPriceChartNew");
        if (newEl) {
          const ctx = newEl.getContext("2d");
          if (priceChartNewInstance) priceChartNewInstance.destroy();
          priceChartNewInstance = new Chart(ctx, {
            type: "line",
            data: chartData,
            options: chartOptions
          });
        }
      }

      /** === DASHBOARD POPULATION === **/
      async function fetchUserStats(wallet) {
        try {
          const res = await fetch(`${baseURL}/api/userstats?wallet=${wallet}`);
          const stats = await res.json();
          $("walletAddress") && ($("walletAddress").textContent = `Wallet: ${wallet}`);
          $("refCount") && ($("refCount").textContent = stats.referrals?.length ?? 0);
          $("refCountMain") && ($("refCountMain").textContent = stats.referrals?.length ?? 0);
          const referralUrl = `https://waldocoin.live/?ref=${wallet}`;
          $("referralLink") && ($("referralLink").value = referralUrl);
          $("referralLinkMain") && ($("referralLinkMain").value = referralUrl);
          // XP breakdown (match HTML IDs)
          const breakdown = stats.xpBreakdown || {};
          $("likesXP") && ($("likesXP").textContent = `${breakdown.likes ?? 0} XP`);
          $("retweetsXP") && ($("retweetsXP").textContent = `${breakdown.retweets ?? 0} XP`);
          $("battleWinsXP") && ($("battleWinsXP").textContent = `${breakdown.battles ?? 0} XP`);
          $("referralsXP") && ($("referralsXP").textContent = `${breakdown.referrals ?? 0} XP`);
          $("votingXP") && ($("votingXP").textContent = `${breakdown.voting ?? 0} XP`);
          $("stakingBonusXP") && ($("stakingBonusXP").textContent = `${breakdown.stakingBonus ?? 0}%`);

          // Update XP multipliers
          updateXPMultipliers(stats);

          // Level logic
          const level = stats.level || 1, xp = stats.xp || 0;
          const xpFloor = levelThresholds[level - 1] || 0, xpCeil = levelThresholds[level] || (xpFloor + 1000);
          const xpProgress = Math.min(100, Math.floor(((xp - xpFloor) / (xpCeil - xpFloor)) * 100));
          $("userLevelIcon") && ($("userLevelIcon").src = levelImages[level] || levelImages[1]);
          $("userLevelTitle") && ($("userLevelTitle").textContent = levelTitles[level] || `Level ${level}`);
          $("levelProgress") && ($("levelProgress").value = xpProgress);
          $("xpToNextLevel") && ($("xpToNextLevel").textContent = `${calculateXPToNextLevel(xp)} XP to next level`);

          // Move the level indicator with the progress bar
          const indicator = $("levelProgressIndicator");
          if (indicator) {
            // Calculate position based on progress (0% = 0%, 100% = 95% to prevent overflow)
            const position = Math.min(95, xpProgress); // 0% at start, max 95% to prevent edge overflow
            const prev = Number(indicator.getAttribute('data-prev') || 0);
            indicator.style.left = position + '%';
            // Trigger subtle pulse when crossing 25/50/75/100 thresholds
            const thresholds = [25, 50, 75, 100];
            const crossed = thresholds.some(t => prev < t && position >= t);
            if (crossed) {
              indicator.classList.remove('pulse'); // restart animation if already applied
              void indicator.offsetWidth; // reflow to restart CSS animation
              indicator.classList.add('pulse');
              // spawn a spark element
              const spark = document.createElement('div');
              spark.className = 'spark';
              indicator.appendChild(spark);
              setTimeout(() => {
                indicator.classList.remove('pulse');
                spark.remove();
              }, 800);
            }
            indicator.setAttribute('data-prev', String(position));
          }

          // Update enhanced meme score display with dynamic background
          updateMemeScoreDisplay(xp, level);
          // Count up the meme score number
          animateCountUp(document.getElementById('memeScoreDisplay'), xp);


          // Update reward table if level is available from API
          if (Number.isFinite(level)) {

            // === Next Level Requirements Logic ===
            const levelMinRequirements = {
              1: { minted: 0, battles: 0, referrals: 0 },
              2: { minted: 1, battles: 0, referrals: 1 },
              3: { minted: 3, battles: 1, referrals: 2 },
              4: { minted: 7, battles: 3, referrals: 3 },
              5: { minted: 10, battles: 5, referrals: 5 }
            };

            function updateNextLevelRequirements(xp, level, mintedCount, battlesWon, referralsCount) {
              try {
                const currentLevel = Math.max(1, Math.min(level || 1, 5));
                const nextLevel = Math.min(currentLevel + 1, 5);

                // XP to next
                const xpNeeded = calculateXPToNextLevel(xp);
                const xpText = nextLevel > currentLevel ? `${xpNeeded} XP to Level ${nextLevel}` : `Max level reached`;
                const xpEl = document.getElementById("reqXpNeeded");
                if (xpEl) xpEl.textContent = xpText;

                // Requirements
                const req = levelMinRequirements[nextLevel] || { minted: 0, battles: 0, referrals: 0 };
                const mintedOk = (mintedCount || 0) >= (req.minted || 0);
                const battlesOk = (battlesWon || 0) >= (req.battles || 0);
                const referralsOk = (referralsCount || 0) >= (req.referrals || 0);

                const mintedStr = `${mintedCount || 0}/${req.minted || 0} ${mintedOk ? 'âœ…' : 'âŒ'}`;
                const battlesStr = `${battlesWon || 0}/${req.battles || 0} ${battlesOk ? 'âœ…' : 'âŒ'}`;
                const referralsStr = `${referralsCount || 0}/${req.referrals || 0} ${referralsOk ? 'âœ…' : 'âŒ'}`;

                const mintedEl = document.getElementById("reqMintedProgress");
                const battlesEl = document.getElementById("reqBattlesProgress");
                const referralsEl = document.getElementById("reqReferralsProgress");

                if (mintedEl) mintedEl.textContent = mintedStr;
                if (battlesEl) battlesEl.textContent = battlesStr;
                if (referralsEl) referralsEl.textContent = referralsStr;

                // Summary logic: need XP + minted + (battles OR referrals)
                const meetsXP = xpNeeded <= 0;
                const meetsMinted = mintedOk;
                const meetsEngagement = battlesOk || referralsOk;

                const summary = document.getElementById("reqStatusSummary");
                if (summary) {
                  if (currentLevel === 5) {
                    summary.textContent = "ðŸŽ‰ You are at max level (Waldo Legend).";
                    summary.style.color = "#25c2a0";
                  } else {
                    const ok = meetsXP && meetsMinted && meetsEngagement;
                    summary.textContent = ok ? "âœ… All requirements met for next level (awaiting backend update)" : "â³ Keep going to reach next level";
                    summary.style.color = ok ? "#25c2a0" : "#ffd93d";
                  }
                }
              } catch (e) {
                console.warn("Next level requirements update failed:", e);
              }
            }

            console.log('ðŸ“Š User stats loaded, updating reward table for level:', level);
            await generateRewardTable(level);
          }

          // Generate XP trend data if not provided by backend
          let xpTrendData = stats.memeXPTrend;
          console.log('ðŸ“Š Backend XP trend data:', xpTrendData);

          if (!xpTrendData || !Array.isArray(xpTrendData) || xpTrendData.length === 0) {
            console.log('ðŸ“Š Generating mock XP trend data for XP:', stats.xp, 'Level:', stats.level);
            xpTrendData = generateMockXPTrend(stats.xp || 0, stats.level || 1);
          }

          console.log('ðŸ“Š Rendering XP chart with data:', xpTrendData);

          // Force render chart with a small delay to ensure DOM is ready
          setTimeout(() => {
            renderXPTrendChart(xpTrendData);
          }, 100);

          // Update Next Level Requirements card using fetched stats
          try {
            const mintedCount = (window.__waldoMintedCount || 0);
            const referralsCount = Array.isArray(stats.referrals) ? stats.referrals.length : (stats.referrals || 0);
            const battlesWon = stats.battles || 0;
            updateNextLevelRequirements(xp, level, mintedCount, battlesWon, referralsCount);
          } catch (e) {
            console.warn('Next level card update skipped:', e);
          }

        } catch (err) {
          showToast("Error loading user stats", "error");
          console.error("âŒ fetchUserStats error:", err);

          // Still render chart with default data even if stats fail
          console.log('ðŸ“Š Rendering fallback XP chart due to stats error');
          const fallbackData = generateMockXPTrend(0, 1);
          setTimeout(() => {
            renderXPTrendChart(fallbackData);
          }, 100);
        }
      }

      // Update XP Multipliers display with enhanced backend integration
      async function updateXPMultipliers(stats) {
        try {
          console.log('ðŸ”„ Updating XP multipliers with stats:', stats);

          // Fetch additional data for more accurate multipliers
          const wallet = getWallet();
          const [stakingData, battleData, referralData] = await Promise.all([
            fetchStakingMultiplierData(wallet).catch(e => ({ error: e.message })),

            fetchReferralMultiplierData(wallet).catch(e => ({ error: e.message }))
          ]);

          // 1. Locking Bonus Program Multiplier (Staking)
          await updateStakingMultiplier(stats, stakingData);

          // 2. Battle Streak Multiplier (from stats data)
          await updateBattleMultiplier(stats);

          // 3. Level Bonus Multiplier
          await updateLevelMultiplier(stats);

          // 4. Referral Bonus Multiplier
          await updateReferralMultiplier(stats, referralData);

          console.log('âœ… XP multipliers updated successfully');

        } catch (error) {
          console.error("âŒ Error updating XP multipliers:", error);
          setMultipliersError();
        }
      }

      // Individual multiplier update functions
      async function updateStakingMultiplier(stats, stakingData) {
        const card = $("stakingMultiplierCard");
        const value = $("stakingMultiplier");
        const desc = $("stakingMultiplierDesc");
        const status = $("stakingMultiplierStatus");

        if (!value) return;

        try {
          // Try multiple data sources for staking bonus
          let stakingBonus = 0;
          let totalStaked = 0;

          if (stakingData && !stakingData.error) {
            totalStaked = stakingData.totalStaked || 0;
            stakingBonus = stakingData.xpBonus || 0;
          } else if (stats.xpBreakdown?.stakingBonus) {
            stakingBonus = stats.xpBreakdown.stakingBonus;
          } else if (stats.totalStaked) {
            totalStaked = stats.totalStaked;
            // Calculate bonus: 0.1% XP bonus per 1000 WALDO staked (max 10%)
            stakingBonus = Math.min(Math.floor(totalStaked / 1000) * 0.1, 10);
          }

          const multiplier = 1 + (stakingBonus / 100);
          value.textContent = `${multiplier.toFixed(1)}x`;

          if (multiplier > 1) {
            card.className = "xp-multiplier-card active";
            desc.textContent = `${totalStaked.toFixed(0)} WALDO staked (+${stakingBonus}% XP)`;
            status.textContent = `+${stakingBonus}% XP Bonus`;
            status.className = "xp-multiplier-status active";
          } else {
            card.className = "xp-multiplier-card inactive";
            desc.textContent = "Stake WALDO tokens to earn XP bonuses";
            status.textContent = "No Active Bonus";
            status.className = "xp-multiplier-status inactive";
          }

        } catch (error) {
          console.warn("Error updating staking multiplier:", error);
          value.textContent = "Error";
          desc.textContent = "Failed to load staking data";
          status.textContent = "Data Error";
          status.className = "xp-multiplier-status error";
        }
      }

      async function updateBattleMultiplier(stats) {
        const card = $("battleMultiplierCard");
        const value = $("battleMultiplier");
        const desc = $("battleMultiplierDesc");
        const status = $("battleMultiplierStatus");

        if (!value) return;

        try {
          // Try multiple data sources for battle wins
          let battleWins = 0;
          let winStreak = 0;

          if (battleData && !battleData.error) {
            battleWins = battleData.totalWins || 0;
            winStreak = battleData.currentStreak || 0;
          } else if (stats.battles) {
            battleWins = stats.battles;
          } else if (stats.battleStats) {
            battleWins = stats.battleStats.wins || 0;
            winStreak = stats.battleStats.streak || 0;
          }

          // Calculate multiplier: 2% per win, max 20% total (10 wins max)
          const multiplier = Math.min(1 + (battleWins * 0.02), 1.2);
          value.textContent = `${multiplier.toFixed(1)}x`;

          if (multiplier > 1) {
            card.className = "xp-multiplier-card active";
            if (winStreak > 0) {
              desc.textContent = `${battleWins} wins, ${winStreak} streak (+${((multiplier - 1) * 100).toFixed(0)}% XP)`;
              status.textContent = `ðŸ”¥ ${winStreak} Win Streak`;
            } else {
              desc.textContent = `${battleWins} total wins (+${((multiplier - 1) * 100).toFixed(0)}% XP)`;
              status.textContent = `${battleWins} Battle Wins`;
            }
            status.className = "xp-multiplier-status active";
          } else {
            card.className = "xp-multiplier-card inactive";
            desc.textContent = "Win meme battles to earn XP bonuses";
            status.textContent = "No Wins Yet";
            status.className = "xp-multiplier-status inactive";
          }

        } catch (error) {
          console.warn("Error updating battle multiplier:", error);
          value.textContent = "Error";
          desc.textContent = "Failed to load battle data";
          status.textContent = "Data Error";
          status.className = "xp-multiplier-status error";
        }
      }

      async function updateLevelMultiplier(stats) {
        const card = $("levelMultiplierCard");
        const value = $("levelMultiplier");
        const desc = $("levelMultiplierDesc");
        const status = $("levelMultiplierStatus");

        if (!value) return;

        try {
          const level = stats.level || 1;
          const xp = stats.xp || 0;

          // Calculate multiplier: 5% per level above 1, max 20% at level 5
          const multiplier = 1 + ((level - 1) * 0.05);
          value.textContent = `${multiplier.toFixed(1)}x`;

          const levelNames = ["", "Waldo Watcher", "Waldo Scout", "Waldo Agent", "Waldo Commander", "Waldo Legend"];
          const levelName = levelNames[level] || `Level ${level}`;

          if (level > 1) {
            card.className = "xp-multiplier-card active";
            desc.textContent = `${levelName} (${xp} XP) (+${((multiplier - 1) * 100).toFixed(0)}% XP)`;
            status.textContent = `Level ${level} Bonus`;
            status.className = "xp-multiplier-status active";
          } else {
            card.className = "xp-multiplier-card inactive";
            desc.textContent = `${levelName} - Level up for XP bonuses`;
            status.textContent = "Level 1 (No Bonus)";
            status.className = "xp-multiplier-status inactive";
          }

        } catch (error) {
          console.warn("Error updating level multiplier:", error);
          value.textContent = "Error";
          desc.textContent = "Failed to load level data";
          status.textContent = "Data Error";
          status.className = "xp-multiplier-status error";
        }
      }

      async function updateReferralMultiplier(stats, referralData) {
        const card = $("referralMultiplierCard");
        const value = $("referralMultiplier");
        const desc = $("referralMultiplierDesc");
        const status = $("referralMultiplierStatus");

        if (!value) return;

        try {
          // Try multiple data sources for referrals
          let referralCount = 0;
          let activeReferrals = 0;

          if (referralData && !referralData.error) {
            referralCount = referralData.totalReferrals || 0;
            activeReferrals = referralData.activeReferrals || 0;
          } else if (stats.referrals) {
            referralCount = Array.isArray(stats.referrals) ? stats.referrals.length : stats.referrals;
          } else if (stats.referralStats) {
            referralCount = stats.referralStats.total || 0;
            activeReferrals = stats.referralStats.active || 0;
          }

          // Calculate multiplier: 1% per referral, max 15% (15 referrals max)
          const multiplier = Math.min(1 + (referralCount * 0.01), 1.15);
          value.textContent = `${multiplier.toFixed(1)}x`;

          if (referralCount > 0) {
            card.className = "xp-multiplier-card active";
            if (activeReferrals > 0) {
              desc.textContent = `${referralCount} referrals, ${activeReferrals} active (+${((multiplier - 1) * 100).toFixed(0)}% XP)`;
              status.textContent = `${activeReferrals} Active Referrals`;
            } else {
              desc.textContent = `${referralCount} total referrals (+${((multiplier - 1) * 100).toFixed(0)}% XP)`;
              status.textContent = `${referralCount} Referrals`;
            }
            status.className = "xp-multiplier-status active";
          } else {
            card.className = "xp-multiplier-card inactive";
            desc.textContent = "Invite friends with your referral link for XP bonuses";
            status.textContent = "No Referrals Yet";
            status.className = "xp-multiplier-status inactive";
          }

        } catch (error) {
          console.warn("Error updating referral multiplier:", error);
          value.textContent = "Error";
          desc.textContent = "Failed to load referral data";
          status.textContent = "Data Error";
          status.className = "xp-multiplier-status error";
        }
      }

      // Backend data fetching functions for multipliers
      async function fetchStakingMultiplierData(wallet) {
        try {
          const response = await fetch(`${baseURL}/api/staking/positions/${wallet}`);
          const data = await response.json();

          if (data.success && data.positions) {
            const totalStaked = data.positions.reduce((sum, pos) => sum + (pos.amount || 0), 0);
            const xpBonus = Math.min(Math.floor(totalStaked / 1000) * 0.1, 10); // 0.1% per 1000 WALDO, max 10%

            return {
              totalStaked,
              xpBonus,
              activePositions: data.positions.filter(p => p.status === 'active').length
            };
          }

          return { totalStaked: 0, xpBonus: 0, activePositions: 0 };
        } catch (error) {
          console.warn('Failed to fetch staking multiplier data:', error);
          throw error;
        }
      }



      async function fetchReferralMultiplierData(wallet) {
        try {
          const response = await fetch(`${baseURL}/api/referral/stats/${wallet}`);
          const data = await response.json();

          if (data.success) {
            return {
              totalReferrals: data.totalReferrals || 0,
              activeReferrals: data.activeReferrals || 0,
              totalEarned: data.totalEarned || 0
            };
          }

          return { totalReferrals: 0, activeReferrals: 0, totalEarned: 0 };
        } catch (error) {
          console.warn('Failed to fetch referral multiplier data:', error);
          throw error;
        }
      }

      // Error state handler
      function setMultipliersError() {
        const multipliers = ['staking', 'battle', 'level', 'referral'];

        multipliers.forEach(type => {
          const value = $(`${type}Multiplier`);
          const desc = $(`${type}MultiplierDesc`);
          const status = $(`${type}MultiplierStatus`);
          const card = $(`${type}MultiplierCard`);

          if (value) value.textContent = "Error";
          if (desc) desc.textContent = "Failed to load multiplier data";
          if (status) {
            status.textContent = "Connection Error";
            status.className = "xp-multiplier-status error";
          }
          if (card) card.className = "xp-multiplier-card inactive";
        });
      }

      // Initialize multipliers with loading state
      function initializeMultipliers() {
        const multipliers = [
          { type: 'staking', label: 'Loading bonus data...' },
          { type: 'battle', label: 'Loading battle data...' },
          { type: 'level', label: 'Loading level data...' },
          { type: 'referral', label: 'Loading referral data...' }
        ];

        multipliers.forEach(({ type, label }) => {
          const value = $(`${type}Multiplier`);
          const desc = $(`${type}MultiplierDesc`);
          const status = $(`${type}MultiplierStatus`);

          if (value) value.textContent = "ðŸ”„";
          if (desc) desc.textContent = label;
          if (status) {
            status.textContent = "Loading...";
            status.className = "xp-multiplier-status loading";
          }
        });
      }

      // Update Meme Score Display with Dynamic Background
      function updateMemeScoreDisplay(xp, level) {
        try {
          const scoreDisplay = document.getElementById("memeScoreDisplay");
          const scoreCard = document.getElementById("memeScoreCard");
          const currentLevelEl = document.getElementById("currentLevel");
          const nextLevelInfoEl = document.getElementById("nextLevelInfo");

          if (!scoreDisplay || !scoreCard) return;

          // Update the score with animation
          scoreDisplay.textContent = xp || 0;

          // Remove existing level background classes
          scoreCard.classList.remove('level-bg-1', 'level-bg-2', 'level-bg-3', 'level-bg-4', 'level-bg-5');

          // Add appropriate background class based on level
          const currentLevel = level || 1;
          const bgClass = `level-bg-${Math.min(currentLevel, 5)}`; // Max 5 levels for backgrounds
          scoreCard.classList.add(bgClass);

          // Update level text dynamically
          if (currentLevelEl) {
            const levelTitle = levelTitles[currentLevel] || `Level ${currentLevel}`;
            currentLevelEl.textContent = `Level ${currentLevel}: ${levelTitle}`;
          }

          // Update next level info dynamically
          if (nextLevelInfoEl) {
            const xpNeeded = calculateXPToNextLevel(xp);
            const nextLevel = currentLevel + 1;
            if (currentLevel >= 5) {
              nextLevelInfoEl.textContent = "Max Level Reached! ðŸŽ‰";
            } else {
              nextLevelInfoEl.textContent = `${xpNeeded} XP to Level ${nextLevel}`;
            }
          }

          // Add pulsing effect for high scores
          if (xp > 10000) {
            scoreDisplay.style.animation = 'pulse 2s infinite';
          } else {
            scoreDisplay.style.animation = 'none';
          }

          // Color changes based on level
          const levelColors = {
            1: '#25c2a0', // Green (Beginner)
            2: '#4fc3f7', // Light Blue (Novice)
            3: '#ffd93d', // Yellow (Intermediate)
            4: '#ff6b6b', // Red (Advanced)
            5: '#9c27b0'  // Purple (Expert)
          };

          const color = levelColors[Math.min(currentLevel, 5)] || '#25c2a0';
          scoreDisplay.style.color = color;
          scoreDisplay.style.textShadow = `
      0 0 20px ${color},
      0 0 40px ${color},
      2px 2px 4px rgba(0,0,0,0.8)
    `;

        } catch (error) {
          console.warn("Error updating meme score display:", error);
        }
      }
      async function fetchConversionRate() {
        try {
          const res = await fetch(`${baseURL}/api/conversion`);
          const data = await res.json();
          $("waldoConversion") && ($("waldoConversion").textContent = `${data.waldoToUSD} USD / ${data.waldoToXRP} XRP`);
          $("waldoEarnings") && ($("waldoEarnings").textContent = `${data.totalWaldo} WALDO = ${data.totalUSD} USD`);
        } catch (err) { showToast("Could not load rates", "error"); }
      }
      async function loadTopMeme() {
        try {
          const res = await fetch(`${baseURL}/api/topMeme`);
          const data = await res.json();

          if (data && data.likes !== undefined) {
            $("topMemeLikes") && ($("topMemeLikes").textContent = data.likes);
          }

          if (data && data.image) {
            $("topMemeImage") && ($("topMemeImage").src = data.image);
          }

          if (data && data.author && data.id) {
            $("topMemeLink") && ($("topMemeLink").href = `https://x.com/${data.author}/status/${data.id}`);
          }
        } catch (err) {
          console.warn('Top meme not available:', err.message);
        }
      }

      // Load staking stats summary (Perâ€‘Meme redemptions + ecosystem total)
      async function fetchStakingStatsSummary() {
        try {
          const res = await fetch(`${baseURL}/api/staking/stats`);
          const data = await res.json();
          if (!data || !data.success) return;

          // Update ecosystem-wide total staked
          if (data.stats && data.stats.overview) {
            const totalStakedDisplay = document.getElementById('totalStakedDisplay');
            if (totalStakedDisplay) {
              const ecosystemTotal = parseFloat(data.stats.overview.totalStaked) || 0;
              totalStakedDisplay.textContent = `${ecosystemTotal.toLocaleString()} WALDO`;
            }
          }

          // Update per-meme redemptions
          const s = data.stats && data.stats.perMemeRedemptions;
          if (!s) return;

          const countEl = document.getElementById('pmRedCount');
          const totalEl = document.getElementById('pmRedTotal');
          const listEl = document.getElementById('pmRedList');

          if (countEl) countEl.textContent = (s.count || 0).toLocaleString();
          if (totalEl) totalEl.textContent = `${Number(s.totalAmount || 0).toFixed(2)} WALDO`;

          if (listEl) {
            if (!s.last10 || s.last10.length === 0) {
              listEl.innerHTML = '<div class="js-no-stakes" style="font-size:16px;color:#888;text-align:center;padding:20px 0;">No matured perâ€‘meme redemptions yet</div>';
            } else {
              listEl.innerHTML = '<ul style="list-style:none;padding:0;margin:0;"></ul>';
              const ul = listEl.querySelector('ul');
              s.last10.forEach(ev => {
                const short = ev.txid ? `${ev.txid.slice(0, 8)}â€¦${ev.txid.slice(-6)}` : 'â€”';
                const when = ev.timestamp ? new Date(ev.timestamp).toLocaleString() : '';
                const li = document.createElement('li');
                li.style.margin = '6px 0';
                li.innerHTML = `+${(Number(ev.amount) || 0).toFixed(2)} WALDO â€¢ <a class="xrpl-link-green" href="https://livenet.xrpl.org/transactions/${ev.txid}" target="_blank" rel="noopener">${short}</a> <span style="color:#888;">${when}</span>`;
                ul.appendChild(li);
              });
            }
          }
        } catch (e) {
          console.warn('Staking stats summary failed:', e);
        }
      }

      // Fetch total burned tokens
      async function fetchTotalBurned() {
        try {
          const res = await fetch(`${baseURL}/api/burn/total`);
          const data = await res.json();

          if (data.success) {
            // Update total burned display
            const totalBurnedEl = document.getElementById('totalBurnedDisplay');
            if (totalBurnedEl) {
              totalBurnedEl.textContent = (data.totalBurned || 0).toLocaleString();
            }

            // Update recent burns list
            const recentBurnsList = document.getElementById('recentBurnsList');
            if (recentBurnsList && data.recentBurns && data.recentBurns.length > 0) {
              recentBurnsList.innerHTML = data.recentBurns.map(burn => {
                const amount = (burn.amount || 0).toLocaleString();
                const date = burn.timestamp ? new Date(burn.timestamp).toLocaleDateString() : '';
                const reason = burn.reason || 'Token burn';
                return `
                  <li class="activity-item">
                    <span class="activity-icon">ðŸ”¥</span>
                    <span class="activity-text">${amount} WALDO burned - ${reason}</span>
                    <span class="activity-time">${date}</span>
                  </li>
                `;
              }).join('');
            } else if (recentBurnsList) {
              recentBurnsList.innerHTML = `
                <li class="activity-item">
                  <span class="activity-icon">ðŸ”¥</span>
                  <span class="activity-text">No burns yet</span>
                </li>
              `;
            }
          }
        } catch (e) {
          console.warn('Failed to fetch burn data:', e);
        }
      }

      // === Meme Table Logic ===
      async function fetchMemes(wallet, page = 1, perPage = 10) {
        try {
          const res = await fetch(`${baseURL}/api/tweets?wallet=${wallet}&page=${page}&perPage=${perPage}`);
          const data = await res.json();
          renderMemeTable(data.memes || [], wallet);
          renderMemePagination(data.totalPages || 1, page, data.totalMemes || 0);
        } catch (e) {
          showToast("Could not load memes", "error");
        }
      }

      // Show all memes without pagination
      async function fetchAllMemes(wallet) {
        try {
          const res = await fetch(`${baseURL}/api/tweets?wallet=${wallet}&page=1&perPage=1000`); // Large number to get all
          const data = await res.json();
          renderMemeTable(data.memes || [], wallet);
          renderMemePagination(0, 1, data.totalMemes || 0); // 0 totalPages = show all mode
        } catch (e) {
          showToast("Could not load all memes", "error");
        }
      }
      function renderMemeTable(memes, wallet) {
        const tbody = $("memeTableBody");
        if (!tbody) return;
        tbody.innerHTML = "";

        if (!memes || memes.length === 0) {
          tbody.innerHTML = '<tr><td colspan="9" class="js-table-empty">No memes found for this wallet</td></tr>';
          return;
        }

        memes.forEach(meme => {
          // Ensure meme has required properties
          if (!meme || !meme.id) return;

          const isMintable = (meme.xp || 0) >= 60;
          const imageUrl = meme.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImciIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiMyNWMyYTAiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMGZmODgiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0idXJsKCNnKSIgcng9IjgiLz48dGV4dCB4PSI1MCIgeT0iNjAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0MCIgZmlsbD0iIzAwMCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+8J+QuDwvdGV4dD48L3N2Zz4=';

          // Create Twitter link from tweet ID or URL
          let twitterLink = '#';
          let twitterDisplay = 'View Tweet';

          if (meme.tweetId) {
            twitterLink = `https://twitter.com/i/web/status/${meme.tweetId}`;
            twitterDisplay = 'ðŸ¦ Tweet';
          } else if (meme.tweetUrl) {
            twitterLink = meme.tweetUrl;
            twitterDisplay = 'ðŸ¦ Tweet';
          } else if (meme.url) {
            twitterLink = meme.url;
            twitterDisplay = 'ðŸ¦ Tweet';
          }

          tbody.innerHTML += `
      <tr>
        <td><img class="meme-thumb" src="${imageUrl}" alt="meme" onclick="showNFTModal('${imageUrl}')" onerror="handleImageError(this)" crossorigin="anonymous"></td>
        <td><a href="${twitterLink}" target="_blank" rel="noopener" style="color: #25c2a0; text-decoration: none; font-size: 0.9em;">${twitterDisplay}</a></td>
        <td>${meme.retweets || 0}</td>
        <td>${meme.likes || 0}</td>
        <td>${meme.xp || 0}</td>
        <td>${meme.tier || '-'}</td>
        <td><button onclick="claimMeme('${meme.id}', ${meme.tier || 1})" class="button-style" ${meme.claimed ? 'disabled' : ''}>Claim</button></td>
        <td><button onclick="stakeMeme('${meme.id}', ${meme.tier || 1})" class="button-style" ${meme.staked ? 'disabled' : ''}>Stake</button></td>
        <td><button onclick="mintMeme('${meme.id}', '${imageUrl}')" class="button-style" ${isMintable ? "" : "disabled"}>Mint</button></td>
      </tr>`;
        });
      }
      function renderMemePagination(totalPages, currentPage, totalMemes = 0) {
        const pag = $("pagination");
        if (!pag) return;
        pag.innerHTML = "";
        const wallet = getWallet();
        if (!wallet) return; // Don't render pagination if no wallet

        // Show "Show All" button if there are memes and we're in paginated mode
        if (totalMemes > 10 && totalPages > 0) {
          pag.innerHTML += `<button onclick="fetchAllMemes('${wallet}')" style="background: #25c2a0; color: white; margin-right: 10px;">ðŸ“‹ Show All (${totalMemes})</button>`;
        }

        // Show "Back to Pages" button if we're in show all mode (totalPages = 0)
        if (totalPages === 0 && totalMemes > 10) {
          pag.innerHTML += `<button onclick="fetchMemes('${wallet}', 1)" style="background: #666; color: white;">ðŸ“„ Back to Pages</button>`;
          return;
        }

        // Only show pagination if there are multiple pages
        if (totalPages <= 1) {
          return; // Hide pagination for single page
        }

        for (let i = 1; i <= totalPages; i++) {
          pag.innerHTML += `<button onclick="fetchMemes('${wallet}', ${i})" ${i === currentPage ? 'class="js-pagination-bold"' : ''}>${i}</button>`;
        }
      }
      // Claim/Stake/Mint Handlers
      async function claimMeme(id, tier) {
        if (!FEATURES.MEME_CLAIMING) {
          showToast("ðŸš§ Meme claiming temporarily disabled", "info");
          return;
        }

        try {
          const res = await fetch(`${baseURL}/api/claim`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ wallet: getWallet(), memeId: id, tier, stake: false })
          });
          const data = await res.json();
          if (data.success) showToast(data.message || "Claim successful!", "success");
          else {
            if (data && data.details && data.details.requiredWaldo !== undefined) {
              const { waldoPerXrp, minXrp, requiredWaldo, balance } = data.details;
              showToast(`You need at least ${requiredWaldo.toLocaleString()} WALDO (~${minXrp} XRP at ${waldoPerXrp.toLocaleString()} WALDO/XRP). You currently have ${Number(balance).toLocaleString()} WALDO.`, "error");
            } else {
              showToast(data.error || "Claim failed", "error");
            }
          }
          fetchMemes(getWallet()); // Refresh
        } catch (e) {
          console.error('Claim error:', e);
          showToast("Claim error: " + e.message, "error");
        }
      }
      async function stakeMeme(id, tier) {
        try {
          const res = await fetch(`${baseURL}/api/claim`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ wallet: getWallet(), memeId: id, tier, stake: true })
          });
          const data = await res.json();
          if (data.success) showToast("Stake started! Check your XAMAN wallet.", "success");
          else showToast(data.error || "Stake failed", "error");
          fetchMemes(getWallet());
        } catch (e) { showToast("Stake error", "error"); }
      }
      async function mintMeme(id, img) {
        // Open modal for mint confirmation if needed, then call backend
        showNFTModal(img);
        if (!confirm("Mint this meme as NFT? (50 WALDO fee applies)")) return;
        try {
          const res = await fetch(`${baseURL}/api/mint`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ wallet: getWallet(), memeId: id })
          });
          const data = await res.json();
          if (data.success) {
            showToast("Mint initiated. Sign in wallet!", "success");
            // Refresh both memes and NFT collection
            fetchMemes(getWallet());
            fetchNFTCollection(getWallet());
          } else {
            if (data && data.details && data.details.requiredWaldo !== undefined) {
              const { waldoPerXrp, minXrp, requiredWaldo, balance } = data.details;
              showToast(`You need at least ${requiredWaldo.toLocaleString()} WALDO (~${minXrp} XRP at ${waldoPerXrp.toLocaleString()} WALDO/XRP). You currently have ${Number(balance).toLocaleString()} WALDO.`, "error");
            } else {
              showToast(data.error || "Mint failed", "error");
            }
          }
        } catch (e) { showToast("Mint error", "error"); }
      }
      window.claimMeme = claimMeme;
      window.stakeMeme = stakeMeme;
      window.mintMeme = mintMeme;
      window.showNFTModal = showNFTModal; // Needed for thumbnail click
      window.showNFTDetails = showNFTDetails; // Needed for NFT collection clicks

      // Debug function to test meme functionality
      window.debugMemes = function () {
        const wallet = getWallet();
        console.log('ðŸ” Debug Memes - Wallet:', wallet);

        if (!wallet) {
          console.error('âŒ No wallet found');
          return;
        }

        console.log('ðŸ“¡ Fetching memes...');
        fetchMemes(wallet).then(() => {
          console.log('âœ… Memes fetch completed');
        }).catch(error => {
          console.error('âŒ Memes fetch failed:', error);
        });
      };

      // Handle image loading errors and CORS issues
      function handleImageError(img) {
        console.warn('Image failed to load:', img.src);
        // Replace with CSS-based placeholder instead of another image
        img.style.display = 'none';

        // Create a CSS placeholder div
        const placeholder = document.createElement('div');
        placeholder.style.cssText = `
    width: ${img.width || 100}px;
    height: ${img.height || 100}px;
    background: linear-gradient(135deg, #25c2a0 0%, #00ff88 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    color: #000;
    font-weight: bold;
    font-size: 2em;
  `;
        placeholder.textContent = 'ðŸ¸';
        placeholder.title = 'WALDO Meme';

        // Replace the image with the placeholder
        img.parentNode.insertBefore(placeholder, img);
        img.remove();
      }

      // Add global error handler for undefined resources
      window.addEventListener('error', function (e) {
        if (e.target && e.target.tagName === 'IMG') {
          console.warn('Image load error:', e.target.src);
          handleImageError(e.target);
        }
      }, true);
      // On page load, after initWaldoDashboard, call: fetchMemes(getWallet());
      // === NFT Modal Preview Logic ===
      function showNFTModal(img) {
        const modal = document.getElementById("nftModal");
        const modalImg = document.getElementById("nftModalImg");
        if (!modal || !modalImg) return;
        modal.style.display = "block";
        modalImg.src = img;
      }
      function closeNFTModal() {
        const modal = document.getElementById("nftModal");
        if (modal) modal.style.display = "none";
      }
      window.closeNFTModal = closeNFTModal;

      // === Staking Modal & Functions ===
      function showStakingModal() {
        const modal = document.getElementById("stakingModal");
        if (!modal) return;
        modal.style.display = "block";

        // Reset form
        document.getElementById("stakeAmount").value = "";
        document.getElementById("stakeDuration").value = "30";
        document.getElementById("stakingEstimate").textContent = "Select amount and duration";

        // Add event listeners for real-time calculation
        const amountInput = document.getElementById("stakeAmount");
        const durationSelect = document.getElementById("stakeDuration");

        const updateEstimate = () => {
          const amount = parseFloat(amountInput.value) || 0;
          const duration = parseInt(durationSelect.value) || 30;

          // Use flat bonus rates (not annualized APY) - matches backend calculation
          let bonusPercent;
          if (duration >= 365) {
            bonusPercent = 45; // +45% flat bonus for 365 days
          } else if (duration >= 180) {
            bonusPercent = 25; // +25% flat bonus for 180 days
          } else if (duration >= 90) {
            bonusPercent = 18; // +18% flat bonus for 90 days
          } else {
            bonusPercent = 12; // +12% flat bonus for 30 days
          }

          if (amount > 0) {
            // Calculate as flat bonus (not annualized)
            const totalRewards = amount * (bonusPercent / 100);
            const finalAmount = amount + totalRewards;

            document.getElementById("stakingEstimate").innerHTML = `
        <div class="js-estimate-rewards">ðŸ’° Estimated Rewards: ${totalRewards.toFixed(2)} WALDO</div>
        <div class="js-estimate-total">ðŸ“ˆ Total Return: ${finalAmount.toFixed(2)} WALDO</div>
        <div class="js-estimate-apy">+${bonusPercent}% bonus | Duration: ${duration} days</div>
      `;
          } else {
            document.getElementById("stakingEstimate").textContent = "Enter amount to see estimate";
          }
        };

        amountInput.addEventListener("input", updateEstimate);
        durationSelect.addEventListener("change", updateEstimate);
      }

      function closeStakingModal() {
        const modal = document.getElementById("stakingModal");
        if (modal) modal.style.display = "none";
      }

      // === Chart Modal Functions ===
      function openChartModal() {
        const modal = document.getElementById("chartModal");
        if (!modal) return;
        modal.style.display = "block";

        // Render expanded chart with stored data
        if (lastChartData && window.Chart) {
          const canvas = document.getElementById("waldoPriceChartExpanded");
          if (canvas) {
            const ctx = canvas.getContext("2d");
            if (priceChartExpandedInstance) {
              priceChartExpandedInstance.destroy();
            }

            const chartOptions = {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: true },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#25c2a0',
                  bodyColor: '#fff',
                  borderColor: '#25c2a0',
                  borderWidth: 1,
                  padding: 12,
                  displayColors: false,
                  callbacks: {
                    label: function (context) {
                      return `$${context.parsed.y.toFixed(8)}`;
                    }
                  }
                }
              },
              scales: {
                x: {
                  grid: { color: 'rgba(255, 255, 255, 0.1)' },
                  ticks: { color: '#ccc' }
                },
                y: {
                  grid: { color: 'rgba(255, 255, 255, 0.1)' },
                  ticks: {
                    color: '#ccc',
                    callback: function (value) {
                      return '$' + value.toFixed(8);
                    }
                  }
                }
              }
            };

            priceChartExpandedInstance = new Chart(ctx, {
              type: "line",
              data: lastChartData.data,
              options: chartOptions
            });
          }
        }
      }

      function closeChartModal() {
        const modal = document.getElementById("chartModal");
        if (modal) modal.style.display = "none";
      }

      // === XP Chart Modal Functions ===
      function openXPChartModal() {
        const modal = document.getElementById("xpChartModal");
        if (!modal) return;
        modal.style.display = "block";

        // Render expanded XP chart with stored data
        if (xpChartModalData) {
          const canvas = document.getElementById("xpChartExpanded");
          if (canvas) {
            // Use larger version of simple chart for modal
            drawSimpleXPChart(canvas, xpChartModalData);
          }
        }
      }

      function closeXPChartModal() {
        const modal = document.getElementById("xpChartModal");
        if (modal) modal.style.display = "none";
      }

      /** === ACTIVITY MODAL === **/
      function openActivityModal() {
        const modal = document.getElementById("activityModal");
        if (modal) {
          modal.style.display = "flex";
          loadExpandedActivity();
        }
      }

      function closeActivityModal() {
        const modal = document.getElementById("activityModal");
        if (modal) modal.style.display = "none";
      }

      async function loadExpandedActivity() {
        const expandedFeed = $("activityFeedExpanded");
        if (!expandedFeed) return;

        const wallet = getWallet();
        if (!wallet) {
          expandedFeed.innerHTML = `
            <li class="activity-item">
              <span class="activity-icon">ðŸ”—</span>
              <span class="activity-text">Connect your wallet to see activity</span>
              <span class="activity-time">Now</span>
            </li>
          `;
          return;
        }

        try {
          // Try to fetch real activity data from backend first
          const res = await fetch(`${baseURL}/api/activity?wallet=${wallet}&limit=20`);

          if (res.ok) {
            const data = await res.json();
            if (data.success && data.activities && data.activities.length > 0) {
              // Use real activity data
              expandedFeed.innerHTML = data.activities.map(activity => `
                <li class="activity-item">
                  <span class="activity-icon">${activity.icon || 'ðŸ“Š'}</span>
                  <span class="activity-text">${activity.text || activity.message}</span>
                  <span class="activity-time">${activity.time || new Date(activity.timestamp).toLocaleString()}</span>
                </li>
              `).join('');
              return;
            }
          }

          // Show empty state if API doesn't exist or returns no data
          console.log('No activity data available yet');
          expandedFeed.innerHTML = `
            <li class="activity-item" style="text-align: center; padding: 40px 20px; color: #888;">
              <span class="activity-icon">ðŸ“Š</span>
              <span class="activity-text">No activity yet. Start using WALDOCOIN features to see your activity history here!</span>
              <span class="activity-time"></span>
            </li>
          `;
        } catch (e) {
          console.warn('Activity loading failed:', e);
          // Show empty state on error
          expandedFeed.innerHTML = `
            <li class="activity-item" style="text-align: center; padding: 40px 20px; color: #888;">
              <span class="activity-icon">ðŸ“Š</span>
              <span class="activity-text">No activity yet. Start using WALDOCOIN features to see your activity history here!</span>
              <span class="activity-time"></span>
            </li>
          `;
        }
      }

      function generateMockActivity(wallet) {
        const activities = [
          { icon: 'ðŸŽ‰', text: 'Welcome to WALDOCOIN!', time: 'Just now' },
          { icon: 'ðŸ“Š', text: 'Dashboard loaded successfully', time: '1 min ago' },
          { icon: 'ðŸ”—', text: 'Wallet connected', time: '2 min ago' },
          { icon: 'ðŸ’°', text: 'WALDO balance updated', time: '5 min ago' },
          { icon: 'ðŸ“ˆ', text: 'XP level calculated', time: '10 min ago' },
          { icon: 'ðŸŽ¯', text: 'Staking positions loaded', time: '15 min ago' },
          { icon: 'ðŸ†', text: 'Leaderboard position updated', time: '20 min ago' },
          { icon: 'ðŸ”¥', text: 'Token burn data refreshed', time: '25 min ago' },
          { icon: 'ðŸ“Š', text: 'Price charts initialized', time: '30 min ago' },
          { icon: 'ðŸ¤', text: 'Referral link generated', time: '35 min ago' },
          { icon: 'âš”ï¸', text: 'Battle arena status checked', time: '40 min ago' },
          { icon: 'ðŸ—³ï¸', text: 'DAO proposals loaded', time: '45 min ago' },
          { icon: 'ðŸŽ¨', text: 'Meme collection updated', time: '50 min ago' },
          { icon: 'ðŸ’Ž', text: 'NFT collection synced', time: '55 min ago' },
          { icon: 'ðŸ“±', text: 'Mobile optimization applied', time: '1 hour ago' },
          { icon: 'ðŸ”’', text: 'Security checks completed', time: '1 hour ago' },
          { icon: 'âš¡', text: 'Performance optimized', time: '1 hour ago' },
          { icon: 'ðŸŒŸ', text: 'Premium features unlocked', time: '2 hours ago' },
          { icon: 'ðŸ“Š', text: 'Analytics data processed', time: '2 hours ago' },
          { icon: 'ðŸŽŠ', text: 'Account setup completed', time: '3 hours ago' }
        ];

        return activities.slice(0, 20); // Return latest 20
      }

      async function createStake() {
        const amount = parseFloat(document.getElementById("stakeAmount").value);
        const duration = parseInt(document.getElementById("stakeDuration").value);

        if (!amount || amount <= 0) {
          showToast("Please enter a valid staking amount", "error");
          return;
        }

        if (!duration || duration < 30) {
          showToast("Minimum staking duration is 30 days", "error");
          return;
        }

        try {
          const res = await fetch(`${baseURL}/api/staking/stake`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              wallet: getWallet(),
              amount: amount,
              duration: duration
            })
          });

          const data = await res.json();

          if (data.success) {
            showToast("Staking initiated! Check your XAMAN wallet to sign.", "success");
            closeStakingModal();

            // Open XUMM payment in new window if available
            if (data.redirect) {
              window.open(data.redirect, '_blank');
            }

            // Refresh staking positions after a delay
            setTimeout(() => {
              fetchStakingPositions(getWallet());
            }, 2000);

          } else {
            // Worth policy friendly message
            if (data && data.details && data.details.requiredWaldo !== undefined) {
              const { waldoPerXrp, minXrp, requiredWaldo, balance } = data.details;
              showToast(`You need at least ${requiredWaldo.toLocaleString()} WALDO (~${minXrp} XRP at ${waldoPerXrp.toLocaleString()} WALDO/XRP). You currently have ${Number(balance).toLocaleString()} WALDO.`, "error");
            } else {
              showToast(data.error || "Failed to create stake", "error");
            }
          }

        } catch (error) {
          console.error("Staking error:", error);
          showToast("Error creating stake. Please try again.", "error");
        }
      }

      // Fetch and display user's staking positions
      async function fetchStakingPositions(wallet) {
        try {
          const res = await fetch(`${baseURL}/api/staking/positions/${wallet}`);
          const data = await res.json();

          if (data.success) {
            // Calculate totals from positions
            const totalStaked = data.positions
              .filter(p => p.status === 'active')
              .reduce((sum, p) => sum + (parseFloat(p.amount) || 0), 0);

            const totalRewards = data.positions
              .filter(p => p.status === 'active')
              .reduce((sum, p) => sum + (parseFloat(p.expectedReward) || 0), 0);

            document.getElementById("totalStaked").textContent = `${totalStaked.toFixed(2)} WALDO`;
            document.getElementById("totalRewards").textContent = `${totalRewards.toFixed(2)} WALDO`;

            // Update positions display
            const positionsTable = document.getElementById("stakingPositionsTable");
            if (!positionsTable) {
              console.warn('âš ï¸ stakingPositionsTable element not found');
              return;
            }

            if (data.positions && data.positions.length > 0) {
              positionsTable.innerHTML = data.positions.map(position => {
                // Use endDate from backend (not unlockDate)
                const unlockDate = new Date(position.endDate).toLocaleDateString();
                const now = new Date();
                const unlockDateTime = new Date(position.endDate);
                const bufferMs = 60 * 1000; // 60-second buffer to match backend
                const isMatured = now >= (unlockDateTime.getTime() - bufferMs);

                // Status-based styling
                let statusColor, statusText, actionButton;

                if (position.status === 'redeemed' || position.status === 'completed') {
                  statusColor = '#ffd93d';
                  statusText = 'Redeemed';
                  actionButton = `<span style="color: #ffd93d;">âœ… Completed</span>`;

                } else if (position.status === 'active' && isMatured) {
                  statusColor = '#25c2a0';
                  statusText = 'Ready to Redeem';
                  actionButton = `<button onclick="unstakePosition('${position.stakeId}')" class="button-style" style="font-size: 0.8em; padding: 6px 12px;">ðŸ’° Redeem</button>`;

                } else if (position.status === 'active') {
                  statusColor = '#25c2a0';
                  statusText = 'Active';
                  actionButton = `<span style="color: #888; font-size: 0.8em;">ðŸ”’ Locked</span>`;

                } else {
                  statusColor = '#aaa';
                  statusText = position.status || 'Unknown';
                  actionButton = `<span style="color: #aaa;">${position.status}</span>`;
                }

                const apyPercent = position.apy ? (position.apy).toFixed(1) : '0.0';
                const currentRewards = position.expectedReward || 0;

                return `
                  <tr>
                    <td>${position.stakeId.slice(0, 8)}...</td>
                    <td style="color: ${statusColor};">${position.amount} WALDO</td>
                    <td>${position.duration} days</td>
                    <td>${apyPercent}%</td>
                    <td>+${parseFloat(currentRewards).toFixed(2)} WALDO</td>
                    <td style="color: ${statusColor};">â— ${statusText}</td>
                    <td>${actionButton}</td>
                  </tr>
                `;
              }).join('');
            } else {
              positionsTable.innerHTML = '<tr><td colspan="7" class="staking-positions-empty">No active stakes yet. Create your first stake above!</td></tr>';
            }
          }
        } catch (error) {
          console.error("Error fetching staking positions:", error);
          showToast("Could not load staking positions", "error");
          const positionsTable = document.getElementById("stakingPositionsTable");
          if (positionsTable) {
            positionsTable.innerHTML = '<tr><td colspan="7" class="staking-positions-empty">Error loading stakes. Please refresh.</td></tr>';
          }
        }
      }

      // Unstake/Redeem function - automatically chooses correct endpoint based on maturity
      async function unstakePosition(stakeId) {
        // First check if stake is matured to determine which endpoint to use
        const wallet = getWallet();
        let isMatured = false;

        try {
          const posRes = await fetch(`${baseURL}/api/staking/positions/${wallet}`);
          const posData = await posRes.json();
          if (posData.success) {
            const stake = posData.positions.find(p => p.stakeId === stakeId);
            if (stake) {
              const now = new Date();
              // Backend returns 'endDate', not 'unlockDate'
              const unlockDateTime = new Date(stake.endDate);
              const bufferMs = 60 * 1000; // 60-second buffer to match backend
              isMatured = now >= (unlockDateTime.getTime() - bufferMs);
            }
          }
        } catch (e) {
          console.warn('Could not check stake maturity, defaulting to unstake:', e);
        }

        const action = isMatured ? "redeem" : "unstake";
        const confirmMsg = isMatured ?
          "Are you sure you want to redeem this matured position? You'll receive your full stake + rewards." :
          "Are you sure you want to unstake this position early? A 15% penalty will be applied.";

        if (!confirm(confirmMsg)) return;

        try {
          const endpoint = isMatured ? `${baseURL}/api/staking/redeem` : `${baseURL}/api/staking/unstake`;
          const body = isMatured ?
            { wallet, stakeId } :
            { wallet, stakeId, force: false };

          const res = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });

          const data = await res.json();

          if (data.success) {
            const successMsg = isMatured ?
              "Redemption initiated! Check your XAMAN wallet." :
              "Early unstaking initiated! Check your XAMAN wallet.";
            showToast(successMsg, "success");

            // Open XUMM payment if available
            if (data.qr) {
              window.open(data.qr, '_blank');
            }

            // Refresh positions
            setTimeout(() => {
              fetchStakingPositions(getWallet());
            }, 2000);

          } else {
            showToast(data.error || `Failed to ${action}`, "error");
          }

        } catch (error) {
          console.error("Unstaking error:", error);
          showToast("Error unstaking. Please try again.", "error");
        }
      }

      // Twitter Account Linking
      async function linkTwitterAccount() {
        const twitterHandle = document.getElementById("twitterHandleInput").value.trim();

        if (!twitterHandle) {
          showToast("Please enter a Twitter handle", "error");
          return;
        }

        // Remove @ if user included it
        const cleanHandle = twitterHandle.replace(/^@/, '');

        try {
          const res = await fetch(`${baseURL}/api/linkTwitter`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              wallet: getWallet(),
              twitterHandle: cleanHandle
            })
          });

          const data = await res.json();

          if (data.success) {
            showToast(`âœ… Twitter @${cleanHandle} linked successfully!`, "success");
            document.getElementById("twitterHandleInput").value = "";

            // Refresh user stats to show updated social info
            setTimeout(() => {
              fetchUserStats(getWallet());
            }, 1000);

          } else {
            showToast(data.error || "Failed to link Twitter account", "error");
          }

        } catch (error) {
          console.error("Twitter linking error:", error);
          showToast("Error linking Twitter account. Please try again.", "error");
        }
      }

      // Staking Zone Toggle Function
      function toggleStakingZone() {
        const section = document.getElementById("stakingZoneSection");
        const icon = document.getElementById("stakingZoneToggleIcon");
        if (section.style.display === "none") {
          section.style.display = "block";
          icon.textContent = "â–¼";
          icon.classList.remove("collapsed");
        } else {
          section.style.display = "none";
          icon.textContent = "â–º";
          icon.classList.add("collapsed");
        }
      }

      // Short Term Option Toggle Function
      function toggleShortTermOption() {
        const section = document.getElementById("shortTermSection");
        const icon = document.getElementById("shortTermToggleIcon");

        if (section.classList.contains("expanded")) {
          section.classList.remove("expanded");
          icon.textContent = "â–º";
          icon.classList.add("collapsed");
        } else {
          section.classList.add("expanded");
          icon.textContent = "â–¼";
          icon.classList.remove("collapsed");
        }
      }

      // Long Term Zone Toggle Function
      function toggleLongTermZone() {
        const section = document.getElementById("longTermZoneSection");
        const icon = document.getElementById("longTermZoneToggleIcon");
        if (section.style.display === "none") {
          section.style.display = "block";
          icon.textContent = "â–¼";
          icon.classList.remove("collapsed");
        } else {
          section.style.display = "none";
          icon.textContent = "â–º";
          icon.classList.add("collapsed");
        }
      }

      // Make functions globally available
      window.showStakingModal = showStakingModal;
      window.closeStakingModal = closeStakingModal;
      window.createStake = createStake;
      window.fetchStakingPositions = fetchStakingPositions;
      window.openChartModal = openChartModal;
      window.closeChartModal = closeChartModal;
      window.openXPChartModal = openXPChartModal;
      window.closeXPChartModal = closeXPChartModal;
      window.openActivityModal = openActivityModal;
      window.closeActivityModal = closeActivityModal;
      window.unstakePosition = unstakePosition;
      window.linkTwitterAccount = linkTwitterAccount;
      window.toggleStakingZone = toggleStakingZone;
      window.toggleLongTermZone = toggleLongTermZone;

      // === NFT Collection Logic ===
      async function fetchNFTCollection(wallet) {
        const container = document.getElementById("nftCollectionContainer");
        if (!container || !wallet) return;

        try {
          // Get user's memes that have been minted as NFTs
          const response = await fetch(`${baseURL}/api/userMemes?wallet=${wallet}`);
          const data = await response.json();

          if (data.success && data.memes) {
            const mintedNFTs = data.memes.filter(meme => meme.nft_minted === 'true' || meme.nft_minted === true);

            // Expose minted count globally for requirements card
            window.__waldoMintedCount = mintedNFTs.length;

            if (mintedNFTs.length === 0) {
              container.innerHTML = `
          <div class="nft-empty-state">
            <h3>ðŸ–¼ï¸ No NFTs Yet</h3>
            <p>Mint your first NFT from your memes above!</p>
            <p>Any meme can be minted for 50 WALDO</p>
          </div>
        `;
              return;
            }

            // Calculate rarity for each NFT
            const nftsWithRarity = mintedNFTs.map(nft => {
              const engagementScore = (nft.likes * 0.6) + (nft.retweets * 1.4) + (nft.xp * 10);
              const ageBonus = Math.min((Date.now() - new Date(nft.created_at).getTime()) / (30 * 24 * 60 * 60 * 1000), 2);
              const totalScore = engagementScore * (1 + ageBonus);

              let rarity = 'common';
              if (totalScore >= 10000) rarity = 'legendary';
              else if (totalScore >= 5000) rarity = 'epic';
              else if (totalScore >= 2000) rarity = 'rare';
              else if (totalScore >= 500) rarity = 'uncommon';

              return { ...nft, rarity, engagementScore: Math.floor(totalScore) };
            });

            // Sort by rarity and engagement
            nftsWithRarity.sort((a, b) => b.engagementScore - a.engagementScore);

            container.innerHTML = nftsWithRarity.map(nft => `
        <div class="nft-collection-item" onclick="showNFTDetails('${nft.tweet_id}', '${nft.text}', '${nft.image_url}', '${nft.rarity}')">
          <img src="${nft.image_url}" alt="${nft.text}" class="nft-collection-image" onerror="this.src='https://waldocoin.live/wp-content/uploads/2025/04/1737843965114.jpg'">
          <div class="nft-collection-info">
            <div class="nft-collection-rarity rarity-${nft.rarity}">${nft.rarity}</div>
            <div class="nft-collection-title">${nft.text.substring(0, 60)}${nft.text.length > 60 ? '...' : ''}</div>
            <div class="nft-collection-stats">
              <span>â¤ï¸ ${nft.likes}</span>
              <span>ðŸ” ${nft.retweets}</span>
              <span>â­ ${nft.xp} XP</span>
            </div>
          </div>
        </div>
      `).join('');

          } else {
            container.innerHTML = `
        <div class="nft-empty-state">
          <h3>âŒ Failed to Load</h3>
          <p>Unable to fetch your NFT collection</p>
        </div>
      `;
          }
        } catch (error) {
          console.error('Error fetching NFT collection:', error);
          container.innerHTML = `
      <div class="nft-empty-state">
        <h3>ðŸ”Œ Connection Error</h3>
        <p>Unable to load your NFT collection</p>
      </div>
    `;
        }
      }

      // Show NFT details with marketplace options
      function showNFTDetails(tweetId, title, imageUrl, rarity) {
        const modal = document.getElementById("nftModal");
        const modalImg = document.getElementById("nftModalImg");

        if (!modal || !modalImg) return;

        // Show the NFT image
        modal.style.display = "block";
        modalImg.src = imageUrl;

        // Add marketplace actions (you can enhance this further)
        setTimeout(() => {
          if (confirm(`${title.substring(0, 100)}...\n\nRarity: ${rarity.toUpperCase()}\n\nWould you like to list this NFT for sale on the marketplace?`)) {
            window.open(`/my-nfts.html?highlight=${tweetId}`, '_blank');
          }
        }, 500);
      }

      // CSS: add `.nft-modal { display:none; position:fixed; ... }` if not present
      // === Activity Feed Logic ===
      async function fetchActivity(wallet) {
        const ul = $("activityFeedMain") || $("activityFeed");
        if (!ul) return;

        try {
          // Try to fetch real activity data from backend first
          const res = await fetch(`${baseURL}/api/activity?wallet=${wallet}&limit=3`);

          if (res.ok) {
            const data = await res.json();
            if (data.success && data.activities && data.activities.length > 0) {
              // Use real activity data
              ul.innerHTML = data.activities.map(activity => `
                <li class="activity-item">
                  <span class="activity-icon">${activity.icon || 'ðŸ“Š'}</span>
                  <span class="activity-text">${activity.text || activity.message}</span>
                  <span class="activity-time">${activity.time || new Date(activity.timestamp).toLocaleString()}</span>
                </li>
              `).join('');
              return;
            }
          }

          // Show empty state if API doesn't exist or returns no data
          console.log('No activity data available yet');
          ul.innerHTML = `
            <li class="activity-item" style="text-align: center; padding: 20px; color: #888;">
              <span class="activity-icon">ðŸ“Š</span>
              <span class="activity-text">No recent activity. Connect your wallet and start using WALDOCOIN!</span>
              <span class="activity-time"></span>
            </li>
          `;
        } catch (e) {
          console.warn('Activity fetch failed:', e);
          // Show empty state on error
          ul.innerHTML = `
            <li class="activity-item" style="text-align: center; padding: 20px; color: #888;">
              <span class="activity-icon">ðŸ“Š</span>
              <span class="activity-text">No recent activity. Connect your wallet and start using WALDOCOIN!</span>
              <span class="activity-time"></span>
            </li>
          `;
        }
      }
      // After init, call: fetchActivity(getWallet());








      // === DAO Voting (Placeholder/Scaffold) ===
      async function fetchDAOProposals() {
        const cont = $("proposalContainer");
        if (!cont) return;

        if (!FEATURES.DAO_PROPOSALS) {
          cont.innerHTML = '<div class="dao-placeholder">ðŸ—³ï¸ DAO voting features coming soon...</div>';
          return;
        }

        try {
          const res = await fetch(`${baseURL}/api/dao/proposals`);
          const data = await res.json();
          cont.innerHTML = "";
          (data.proposals || []).forEach(p => {
            cont.innerHTML += `
        <div>
          <b>${p.title}</b> - ${p.status}
          <button onclick="voteDAO('${p.id}', true)">Yes</button>
          <button onclick="voteDAO('${p.id}', false)">No</button>
        </div>
      `;
          });
        } catch (e) {
          console.warn('DAO proposals failed:', e.message);
          cont.innerHTML = '<div class="dao-placeholder">ðŸ—³ï¸ DAO voting temporarily unavailable</div>';
        }
      }
      async function voteDAO(proposalId, yes) {
        try {
          const res = await fetch(`${baseURL}/api/dao/vote`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ wallet: getWallet(), proposalId, vote: yes })
          });
          const data = await res.json();
          if (data.success) showToast("Vote cast!", "success");
          else showToast(data.error || "Vote failed", "error");
          fetchDAOProposals();
        } catch (e) { showToast("Vote error", "error"); }
      }
      window.voteDAO = voteDAO;

      // --- [YOUR ENHANCED FEATURES & MODALS: see your original paste, all logic goes here] ---
      // (No code omitted, all previous functions and event listeners are included below.)

      // (Add any additional functions if you have them below this comment...)


      // ==== INIT EVERYTHING ====
      let dashboardIntervals = [];
      let isDashboardInitialized = false;

      // Test function to force render XP chart
      function testXPChart() {
        console.log('ðŸ§ª Testing XP Chart rendering...');
        const testData = generateMockXPTrend(100, 2);
        renderXPTrendChart(testData);
      }

      // Test function for simple canvas chart
      function testSimpleChart() {
        console.log('ðŸŽ¨ Testing Simple Canvas Chart...');
        const canvas = $("xpChart");
        if (canvas) {
          const testData = generateMockXPTrend(150, 3);
          drawSimpleXPChart(canvas, testData);
        }
      }

      // Make test functions available globally for manual testing
      window.testXPChart = testXPChart;
      window.testSimpleChart = testSimpleChart;

      // Fetch policy worth (eligibility check)
      async function fetchPolicyWorth(wallet) {
        try {
          const res = await fetch(`${baseURL}/api/policy/worth?wallet=${wallet}`);
          const data = await res.json();
          const statusEl = $("eligibilityStatus");
          const detailEl = $("eligibilityDetail");
          const cardEl = $("eligibilityCard");
          const titleEl = $("eligibilityTitle");

          if (!statusEl || !detailEl || !cardEl) return;

          if (data && data.success) {
            const bal = Number(data.balance || 0);
            const req = Number(data.requiredWaldo || 0);
            const needed = Math.max(0, req - bal);

            const iconEl = $("eligibilityIcon");

            if (data.ok) {
              // ELIGIBLE - Green background with big thumbs up
              statusEl.textContent = "âœ… Eligible";
              statusEl.style.color = "#000";
              cardEl.style.background = "linear-gradient(135deg, #25c2a0 0%, #00ff88 100%)";
              cardEl.style.color = "#000";
              if (titleEl) titleEl.style.color = "#000";
              detailEl.style.color = "#000";
              detailEl.textContent = `You have ${bal.toLocaleString()} WALDO (minimum: ${req.toLocaleString()})`;

              // Show big thumbs up
              if (iconEl) {
                iconEl.textContent = "ðŸ‘";
                iconEl.style.opacity = "1";
                iconEl.style.color = "#000";
                iconEl.style.textShadow = "0 0 20px rgba(0,0,0,0.3)";
              }
            } else {
              // NOT ELIGIBLE - Red background with big thumbs down
              statusEl.textContent = "âŒ Not Eligible";
              statusEl.style.color = "#fff";
              cardEl.style.background = "linear-gradient(135deg, #ff6b6b 0%, #ff4444 100%)";
              cardEl.style.color = "#fff";
              if (titleEl) titleEl.style.color = "#fff";
              detailEl.style.color = "#fff";
              detailEl.textContent = `You need ${needed.toLocaleString()} more WALDO (have ${bal.toLocaleString()}, need ${req.toLocaleString()})`;

              // Show big thumbs down
              if (iconEl) {
                iconEl.textContent = "ðŸ‘Ž";
                iconEl.style.opacity = "1";
                iconEl.style.color = "#fff";
                iconEl.style.textShadow = "0 0 20px rgba(255,255,255,0.5)";
              }
            }
          } else {
            // UNKNOWN - Default gray
            statusEl.textContent = "Unknown";
            statusEl.style.color = "#ccc";
            if (titleEl) titleEl.style.color = "";
            cardEl.style.background = "";
            cardEl.style.color = "";
            detailEl.style.color = "#ccc";
            detailEl.textContent = data?.error || "Policy status unavailable";

            // Hide icon for unknown state
            const iconEl = $("eligibilityIcon");
            if (iconEl) {
              iconEl.style.opacity = "0";
            }
          }
        } catch (e) {
          const statusEl = $("eligibilityStatus");
          const detailEl = $("eligibilityDetail");
          const cardEl = $("eligibilityCard");
          const iconEl = $("eligibilityIcon");

          if (statusEl) statusEl.textContent = "Unknown";
          if (detailEl) {
            detailEl.style.color = "#ccc";
            detailEl.textContent = "Policy status unavailable";
          }
          if (cardEl) {
            cardEl.style.background = "";
            cardEl.style.color = "";
          }
          // Hide icon for error state
          if (iconEl) {
            iconEl.style.opacity = "0";
          }
        }
      }

      async function initWaldoDashboard() {


        const wallet = getWallet();
        if (!wallet || isDashboardInitialized) return;

        isDashboardInitialized = true;

        console.log("ðŸš€ Initializing WALDO Dashboard...");

        clearDashboardIntervals();

        try {
          // Generate reward table based on user level (use stats value if available later)
          const userLevel = getCurrentUserLevel(0);
          console.log('ðŸš€ Starting dashboard, generating reward table for level:', userLevel);
          generateRewardTable(userLevel); // Don't await here to avoid blocking dashboard start

          // Initialize XP multipliers with loading state
          initializeMultipliers();

          const loadPromises = [
            fetchUserStats(wallet).catch(e => console.warn('User stats failed:', e)),
            fetchPolicyWorth(wallet).catch(e => console.warn('Worth policy failed:', e)),

            // Add all other data fetches here
            fetchConversionRate().catch(e => console.warn('Conversion rate failed:', e)),
            loadTopMeme().catch(e => console.warn('Top meme failed:', e)),
            fetchMemes(wallet).catch(e => console.warn('Memes failed:', e)),
            fetchNFTCollection(wallet).catch(e => console.warn('NFT collection failed:', e)),
            fetchActivity(wallet).catch(e => console.warn('Activity failed:', e)),
            fetchStakingPositions(wallet).catch(e => console.warn('Staking positions failed:', e)),

            fetchDAOProposals().catch(e => console.warn('DAO proposals failed:', e)),
            fetchStakingStatsSummary().catch(e => console.warn('Staking stats summary failed:', e)),
            initializePriceCharts().catch(e => console.warn('Price charts failed:', e)),
            fetchTotalBurned().catch(e => console.warn('Total burned failed:', e))
          ];

          await Promise.allSettled(loadPromises);
          setupPeriodicUpdates(wallet);

        } catch (error) {
          console.error("âŒ Dashboard initialization failed:", error);
          isDashboardInitialized = false; // Allow retry
        }
      }

      function clearDashboardIntervals() {
        dashboardIntervals.forEach(interval => clearInterval(interval));
        dashboardIntervals = [];

        if (window.battleTimerInterval) {
          clearInterval(window.battleTimerInterval);
          window.battleTimerInterval = null;
        }
      }

      function setupPeriodicUpdates(wallet) {
        clearDashboardIntervals();


        dashboardIntervals.push(
          setInterval(() => fetchUserStats(wallet).catch(e => console.warn('Periodic user stats failed:', e)), 3 * 60 * 1000)
        );
        dashboardIntervals.push(
          setInterval(() => {
            fetchMemes(wallet).catch(e => console.warn('Periodic memes failed:', e));
            fetchNFTCollection(wallet).catch(e => console.warn('Periodic NFT collection failed:', e));
          }, 5 * 60 * 1000)
        );
        dashboardIntervals.push(
          setInterval(() => fetchStakingPositions(wallet).catch(e => console.warn('Periodic staking positions failed:', e)), 2 * 60 * 1000)
        );
        dashboardIntervals.push(
          setInterval(() => fetchPolicyWorth(wallet).catch(e => console.warn('Periodic worth policy failed:', e)), 2 * 60 * 1000)
        );
        dashboardIntervals.push(
          setInterval(() => fetchStakingStatsSummary().catch(e => console.warn('Periodic staking stats summary failed:', e)), 2 * 60 * 1000)
        );
        dashboardIntervals.push(
          setInterval(() => fetchTotalBurned().catch(e => console.warn('Periodic total burned failed:', e)), 5 * 60 * 1000)
        );

      }

      let dashboardStarted = false;

      function startDashboard() {
        const wallet = getWallet();
        if (!wallet) {
          console.log("â³ Waiting for wallet login...");
          return;
        }
        if (dashboardStarted) {
          console.log("âš ï¸ Dashboard already started, skipping...");
          return;
        }
        dashboardStarted = true;
        $("walletAddress") && ($("walletAddress").innerText = `Wallet: ${wallet}`);
        showWaldoNotification("âœ… WALDO wallet connected");
        updateNavWallet(); // Update navigation with wallet info
        initWaldoDashboard().finally(() => {
          const loader = document.getElementById("waldoLoader");
          if (loader) loader.style.display = "none";
          const mainContent = document.getElementById("mainContent");
          if (mainContent) mainContent.style.display = "block";
        });
      }

      function resetDashboard() {
        dashboardStarted = false;
        isDashboardInitialized = false;
        clearDashboardIntervals();
        console.log("ðŸ”„ Dashboard reset");
      }

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize shared authentication listener
        listenForWalletChanges();

        // Initialize staking zone as collapsed
        const stakingZoneSection = document.getElementById("stakingZoneSection");
        if (stakingZoneSection) {
          stakingZoneSection.style.display = "none";
        }

        // Initialize long term zone as collapsed
        const longTermZoneSection = document.getElementById("longTermZoneSection");
        if (longTermZoneSection) {
          longTermZoneSection.style.display = "none";
        }

        // Remove automatic test - was causing infinite loop
        // setTimeout(() => {
        //   console.log('ðŸ§ª Testing XP chart after DOM load...');
        //   testXPChart();
        // }, 1000);

        initializePage();
      });

      function initializePage() {
        // Always show wallet connection screen first
        // This prevents getting stuck on loading
        console.log("ðŸš€ Initializing page - showing connect wallet screen");
        showWalletConnectionScreen();
        setupConnectWalletButton();

        // Check if wallet is already connected in background
        const walletAddress = localStorage.getItem('walletAddress') || localStorage.getItem('xummWallet');

        if (walletAddress) {
          console.log("ðŸ“± Found existing wallet, auto-connecting...");
          // Small delay to show the connect screen briefly, then auto-connect
          setTimeout(() => {
            handleWalletConnection();
          }, 500);
        }
      }

      function showWalletConnectionScreen() {
        const connectionScreen = document.getElementById("walletConnectionScreen");
        if (connectionScreen) connectionScreen.style.display = "flex";
      }

      function hideWalletConnectionScreen() {
        const connectionScreen = document.getElementById("walletConnectionScreen");
        if (connectionScreen) connectionScreen.style.display = "none";
      }

      function showLoader() {
        const loader = document.getElementById("waldoLoader");
        if (loader) loader.style.display = "flex";
      }

      function hideLoader() {
        const loader = document.getElementById("waldoLoader");
        if (loader) loader.style.display = "none";
      }

      function showMainContent() {
        const mainContent = document.getElementById("mainContent");
        if (mainContent) mainContent.style.display = "block";
      }

      function setupConnectWalletButton() {
        const connectBtn = document.getElementById("connectWalletBtn");
        if (connectBtn) {
          connectBtn.addEventListener("click", handleWalletConnection);
        }
      }

      async function handleWalletConnection() {
        try {
          console.log("ðŸ”— Starting wallet connection...");

          // Hide connection screen and show loader
          hideWalletConnectionScreen();
          showLoader();

          // Check if wallet is already connected
          const existingWallet = localStorage.getItem('walletAddress') || localStorage.getItem('xummWallet');

          if (existingWallet) {
            console.log("ðŸ“± Using existing wallet:", existingWallet);
            // Wallet already exists, just start dashboard
            startDashboard();
          } else {
            console.log("ðŸ”— Connecting new wallet...");
            // Connect wallet using existing XUMM functionality
            await connectWallet();

            // Wait a moment for wallet to be stored
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Start dashboard
            startDashboard();
          }

          // Hide loader and show main content
          hideLoader();
          showMainContent();

          console.log("âœ… Dashboard loaded successfully!");

        } catch (error) {
          console.error("âŒ Wallet connection failed:", error);
          // Show connection screen again on error
          hideLoader();
          showWalletConnectionScreen();
          showToast("Wallet connection failed. Please try again.");
        }
      }

      /** === POSTMESSAGE LOGIN SUPPORT === **/
      window.addEventListener("message", (event) => {
        if (
          event.origin !== "https://stats-page.waldocoin.live" &&
          event.origin !== "https://waldocoin.live"
        ) return;

        if (event.data.wallet) {
          setWallet(event.data.wallet);
          sessionStorage.setItem("waldoLoginDesktop", "1");

          if (!dashboardStarted) {
            startDashboard();
          }
        }
      });
      function logoutWallet() {
        // Clear both session and local storage
        sessionStorage.removeItem("xummWallet");
        sessionStorage.removeItem("wallet");
        sessionStorage.removeItem("walletAddress");
        sessionStorage.removeItem("connectedWallet");
        sessionStorage.removeItem("waldoLoginDesktop");

        localStorage.removeItem("xummWallet");
        localStorage.removeItem("wallet");
        localStorage.removeItem("walletAddress");
        localStorage.removeItem("connectedWallet");
        localStorage.removeItem("waldoWalletSync");

        updateWalletUI(null);
        updateNavWallet();
        broadcastWalletChange(null);
        window.location.replace("https://waldocoin.live/?logout=1");
      }

      function updateNavWallet() {
        const wallet = getWallet();
        const navDisplay = document.getElementById('navWalletDisplay');
        const disconnectBtn = document.getElementById('navDisconnectBtn');

        if (wallet && navDisplay) {
          navDisplay.textContent = wallet.substring(0, 8) + '...' + wallet.substring(wallet.length - 6);
          if (disconnectBtn) disconnectBtn.style.display = 'block';

          // Update DAO links to include wallet parameter
          updateDAOLinks(wallet);
        } else {
          navDisplay.textContent = 'Not Connected';
          if (disconnectBtn) disconnectBtn.style.display = 'none';
        }
      }

      function updateDAOLinks(wallet) {
        // Update all DAO links to include wallet parameter
        const daoLinks = document.querySelectorAll('a[href*="dao-portal.waldocoin.live"]');
        daoLinks.forEach(link => {
          const baseUrl = 'https://dao-portal.waldocoin.live';
          link.href = `${baseUrl}?wallet=${encodeURIComponent(wallet)}`;
        });
      }

      function disconnectWallet() {
        logoutWallet(); // Use existing logout function

        // Redirect to main waldocoin.live page after disconnect
        setTimeout(() => {
          window.location.href = 'https://waldocoin.live';
        }, 1500);
      }
      window.logoutWallet = logoutWallet;

      // Connect wallet function
      async function connectWallet() {
        try {
          console.log('ðŸ”— Connecting wallet...');
          const response = await fetch(`${baseURL}/api/login`);
          const data = await response.json();

          if (data.qr && data.uuid) {
            showXummModal('Connect Wallet', data);
            pollLoginStatus(data.uuid);
          } else {
            throw new Error('Failed to create login payload');
          }
        } catch (error) {
          console.error('âŒ Connect wallet error:', error);
          showToast('Failed to connect wallet. Please try again.', 'error');
        }
      }
      window.connectWallet = connectWallet;

      // Update wallet UI based on connection status
      function updateWalletUI(wallet) {
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const walletAddress = document.getElementById('walletAddress');

        if (wallet) {
          connectBtn.style.display = 'none';
          disconnectBtn.style.display = 'block';
          walletAddress.textContent = `Wallet: ${wallet.slice(0, 6)}...${wallet.slice(-6)}`;
        } else {
          connectBtn.style.display = 'block';
          disconnectBtn.style.display = 'none';
          walletAddress.textContent = 'Wallet: Not Connected';
        }

        // Also update navigation wallet display
        updateNavWallet();
      }

      // Poll login status
      function pollLoginStatus(uuid) {
        const pollInterval = setInterval(async () => {
          try {
            const response = await fetch(`${baseURL}/api/login/status?uuid=${uuid}`);
            const status = await response.json();

            if (status.signed && status.account) {
              clearInterval(pollInterval);
              setWallet(status.account);
              sessionStorage.setItem('waldoLoginDesktop', 'true');
              updateWalletUI(status.account);
              hideXummModal();
              showToast('âœ… Wallet connected successfully!', 'success');

              // Process referral if exists
              await processReferralRegistration(status.account);

              // Start dashboard if not already started
              if (!dashboardStarted) {
                startDashboard();
              }
            } else if (status.expired) {
              clearInterval(pollInterval);
              hideXummModal();
              showToast('Login expired. Please try again.', 'error');
            }
          } catch (error) {
            console.error('Login polling error:', error);
          }
        }, 2000);

        // Stop polling after 5 minutes
        setTimeout(() => clearInterval(pollInterval), 300000);
      }

      // Show XUMM modal
      function showXummModal(title, data) {
        const modal = document.getElementById('xummModal');
        const titleEl = document.getElementById('xummTitle');
        const qrEl = document.getElementById('xummQr');
        const mobileLinkEl = document.getElementById('xummMobileLink');
        const qrContainer = document.getElementById('xummQrContainer');
        const loader = document.getElementById('xummLoader');

        titleEl.textContent = title;
        qrEl.src = data.qr || data.refs?.qr_png;

        // Set mobile deep link if available
        if (data.next?.always || data.next?.app) {
          const mobileLink = data.next?.always || data.next?.app;
          mobileLinkEl.href = mobileLink;
          mobileLinkEl.style.display = 'inline-block';
        } else {
          mobileLinkEl.style.display = 'none';
        }

        qrContainer.style.display = 'block';
        loader.style.display = 'none';
        modal.style.display = 'flex';
      }

      // Hide XUMM modal
      function hideXummModal() {
        const modal = document.getElementById('xummModal');
        modal.style.display = 'none';
      }

      window.showXummModal = showXummModal;
      window.hideXummModal = hideXummModal;

      /** === BUTTON HOOKS FOR HTML === **/
      window.dismissWaldoNotification = dismissWaldoNotification;
      window.copyReferral = copyReferral;
    </script>

  </div> <!-- End mainContent -->

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const params = new URLSearchParams(window.location.search);

      // Handle logout notification
      if (params.get("logout") === "1") {
        const toast = document.createElement("div");
        toast.textContent = "âœ… You have been logged out.";
        toast.style.cssText = `
      position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
      background: #222; color: #fff; padding: 16px 36px; border-radius: 8px;
      font-size: 1.25rem; box-shadow: 0 0 12px #25c2a0bb; z-index: 99999;
    `;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3200);
      }

      // Handle referral parameter
      const referralCode = params.get("ref");
      if (referralCode) {
        handleReferralVisit(referralCode);
      }

      // Initialize cross-subdomain wallet sharing
      setupCrossSubdomainWalletSharing();

      // === UNIVERSAL LOGOUT DETECTION REMOVED ===
      // Battle Arena no longer has disconnect button
      // Users disconnect via Stats page only
    });

    // Handle referral link visits
    function handleReferralVisit(referralCode) {
      try {
        // Store referral code in localStorage for when user connects wallet
        localStorage.setItem('waldocoin_referral', referralCode);

        // Show welcome message for referred users
        const toast = document.createElement("div");
        toast.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px;">
            <span>ðŸ¤</span>
            <div>
              <div style="font-weight: 600;">Welcome to WALDOCOIN!</div>
              <div style="font-size: 12px; opacity: 0.9;">You were referred by a friend. Connect your wallet to get started!</div>
            </div>
          </div>
        `;
        toast.style.cssText = `
          position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
          background: #25c2a0; color: white; padding: 15px 20px; border-radius: 8px;
          font-weight: 500; z-index: 99999; box-shadow: 0 0 12px rgba(0,0,0,0.28);
          max-width: 400px; text-align: left;
        `;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 8000);

        console.log(`ðŸ¤ Referral detected: ${referralCode}`);
      } catch (e) {
        console.warn('Failed to handle referral:', e);
      }
    }

    // Process referral registration when wallet connects
    async function processReferralRegistration(walletAddress) {
      try {
        const referralCode = localStorage.getItem('waldocoin_referral');
        if (!referralCode) {
          console.log('No referral code found');
          return;
        }

        console.log(`ðŸ¤ Processing referral registration: ${walletAddress} referred by ${referralCode}`);

        // Register referral with backend
        const response = await fetch(`${baseURL}/api/referral/register`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            wallet: walletAddress,
            referrer: referralCode
          })
        });

        const data = await response.json();

        if (data.success) {
          // Clear referral code from localStorage
          localStorage.removeItem('waldocoin_referral');

          // Show success message
          const toast = document.createElement("div");
          toast.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
              <span>ðŸŽ‰</span>
              <div>
                <div style="font-weight: 600;">Referral Registered!</div>
                <div style="font-size: 12px; opacity: 0.9;">You and your referrer will both earn rewards!</div>
              </div>
            </div>
          `;
          toast.style.cssText = `
            position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
            background: #2ecc71; color: white; padding: 15px 20px; border-radius: 8px;
            font-weight: 500; z-index: 99999; box-shadow: 0 0 12px rgba(0,0,0,0.28);
            max-width: 400px; text-align: left;
          `;
          document.body.appendChild(toast);
          setTimeout(() => toast.remove(), 6000);

          console.log('âœ… Referral registered successfully');
        } else {
          console.warn('Failed to register referral:', data.error);
          // Don't show error to user, just log it
        }
      } catch (e) {
        console.warn('Failed to process referral registration:', e);
        // Don't show error to user, just log it
      }
    }
  </script>

  <!-- XUMM Connection Modal -->
  <div id="xummModal" class="xumm-modal" style="display:none;">
    <div class="xumm-backdrop"></div>
    <div class="xumm-content">
      <h3 id="xummTitle">Connect Wallet</h3>
      <div id="xummQrContainer">
        <img id="xummQr" alt="Scan with XUMM" style="max-width: 280px; border-radius: 10px;" />
        <p class="xumm-hint">Scan the QR code with your Xaman app</p>
        <a id="xummMobileLink" href="#" target="_blank"
          style="display: inline-block; background: #25c2a0; color: #000; padding: 12px 24px; border-radius: 25px; text-decoration: none; font-weight: bold; margin: 15px 0;">ðŸ“±
          Open in Xaman</a>
      </div>
      <div id="xummLoader" class="xumm-loader" style="display:none;">
        <div class="spinner"></div>
        <p>Waiting for wallet connection...</p>
      </div>
    </div>
  </div>

</body>

</html>